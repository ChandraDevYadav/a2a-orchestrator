"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/@a2a-js";
exports.ids = ["vendor-chunks/@a2a-js"];
exports.modules = {

/***/ "(ssr)/./node_modules/@a2a-js/sdk/dist/chunk-67JNQ6TZ.js":
/*!*********************************************************!*\
  !*** ./node_modules/@a2a-js/sdk/dist/chunk-67JNQ6TZ.js ***!
  \*********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AGENT_CARD_PATH: () => (/* binding */ AGENT_CARD_PATH)\n/* harmony export */ });\n// src/constants.ts\nvar AGENT_CARD_PATH = \".well-known/agent-card.json\";\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGEyYS1qcy9zZGsvZGlzdC9jaHVuay02N0pOUTZUWi5qcyIsIm1hcHBpbmdzIjoiOzs7O0FBQUE7QUFDQTs7QUFJRSIsInNvdXJjZXMiOlsid2VicGFjazovL3F1aXotZnJvbnRlbmQvLi9ub2RlX21vZHVsZXMvQGEyYS1qcy9zZGsvZGlzdC9jaHVuay02N0pOUTZUWi5qcz9lODdjIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIHNyYy9jb25zdGFudHMudHNcbnZhciBBR0VOVF9DQVJEX1BBVEggPSBcIi53ZWxsLWtub3duL2FnZW50LWNhcmQuanNvblwiO1xuXG5leHBvcnQge1xuICBBR0VOVF9DQVJEX1BBVEhcbn07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@a2a-js/sdk/dist/chunk-67JNQ6TZ.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@a2a-js/sdk/dist/client/index.js":
/*!*******************************************************!*\
  !*** ./node_modules/@a2a-js/sdk/dist/client/index.js ***!
  \*******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   A2AClient: () => (/* binding */ A2AClient),\n/* harmony export */   createAuthenticatingFetchWithRetry: () => (/* binding */ createAuthenticatingFetchWithRetry)\n/* harmony export */ });\n/* harmony import */ var _chunk_67JNQ6TZ_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../chunk-67JNQ6TZ.js */ \"(ssr)/./node_modules/@a2a-js/sdk/dist/chunk-67JNQ6TZ.js\");\n\n\n// src/client/client.ts\nvar A2AClient = class _A2AClient {\n  agentCardPromise;\n  requestIdCounter = 1;\n  serviceEndpointUrl;\n  // To be populated from AgentCard after fetching\n  customFetchImpl;\n  /**\n   * Constructs an A2AClient instance from an AgentCard.\n   * @param agentCard The AgentCard object.\n   * @param options Optional. The options for the A2AClient including the fetch/auth implementation.\n   */\n  constructor(agentCard, options) {\n    this.customFetchImpl = options?.fetchImpl;\n    if (typeof agentCard === \"string\") {\n      console.warn(\"Warning: Constructing A2AClient with a URL is deprecated. Please use A2AClient.fromCardUrl() instead.\");\n      this.agentCardPromise = this._fetchAndCacheAgentCard(agentCard, options?.agentCardPath);\n    } else {\n      if (!agentCard.url) {\n        throw new Error(\"Provided Agent Card does not contain a valid 'url' for the service endpoint.\");\n      }\n      this.serviceEndpointUrl = agentCard.url;\n      this.agentCardPromise = Promise.resolve(agentCard);\n    }\n  }\n  /**\n   * Dynamically resolves the fetch implementation to use for requests. \n   * Prefers a custom implementation if provided, otherwise falls back to the global fetch.\n   * @returns The fetch implementation.\n   * @param args Arguments to pass to the fetch implementation.\n   * @throws If no fetch implementation is available.\n   */\n  _fetch(...args) {\n    if (this.customFetchImpl) {\n      return this.customFetchImpl(...args);\n    }\n    if (typeof fetch === \"function\") {\n      return fetch(...args);\n    }\n    throw new Error(\n      \"A `fetch` implementation was not provided and is not available in the global scope. Please provide a `fetchImpl` in the A2AClientOptions. For earlier Node.js versions (pre-v18), you can use a library like `node-fetch`.\"\n    );\n  }\n  /**\n   * Creates an A2AClient instance by fetching the AgentCard from a URL then constructing the A2AClient.\n   * @param agentCardUrl The URL of the agent card.\n   * @param options Optional. The options for the A2AClient including the fetch/auth implementation.\n   * @returns A Promise that resolves to a new A2AClient instance.\n   */\n  static async fromCardUrl(agentCardUrl, options) {\n    const fetchImpl = options?.fetchImpl;\n    const requestInit = {\n      headers: { \"Accept\": \"application/json\" }\n    };\n    let response;\n    if (fetchImpl) {\n      response = await fetchImpl(agentCardUrl, requestInit);\n    } else if (typeof fetch === \"function\") {\n      response = await fetch(agentCardUrl, requestInit);\n    } else {\n      throw new Error(\n        \"A `fetch` implementation was not provided and is not available in the global scope. Please provide a `fetchImpl` in the A2AClientOptions. For earlier Node.js versions (pre-v18), you can use a library like `node-fetch`.\"\n      );\n    }\n    if (!response.ok) {\n      throw new Error(`Failed to fetch Agent Card from ${agentCardUrl}: ${response.status} ${response.statusText}`);\n    }\n    let agentCard;\n    try {\n      agentCard = await response.json();\n    } catch (error) {\n      console.error(\"Failed to parse Agent Card JSON:\", error);\n      throw new Error(`Failed to parse Agent Card JSON from ${agentCardUrl}. Original error: ${error.message}`);\n    }\n    return new _A2AClient(agentCard, options);\n  }\n  /**\n   * Helper method to make a generic JSON-RPC POST request.\n   * @param method The RPC method name.\n   * @param params The parameters for the RPC method.\n   * @returns A Promise that resolves to the RPC response.\n   */\n  async _postRpcRequest(method, params) {\n    const endpoint = await this._getServiceEndpoint();\n    const requestId = this.requestIdCounter++;\n    const rpcRequest = {\n      jsonrpc: \"2.0\",\n      method,\n      params,\n      // Cast because TParams structure varies per method\n      id: requestId\n    };\n    const httpResponse = await this._fetchRpc(endpoint, rpcRequest);\n    if (!httpResponse.ok) {\n      let errorBodyText = \"(empty or non-JSON response)\";\n      try {\n        errorBodyText = await httpResponse.text();\n        const errorJson = JSON.parse(errorBodyText);\n        if (errorJson.jsonrpc && errorJson.error) {\n          return errorJson;\n        } else if (!errorJson.jsonrpc && errorJson.error) {\n          throw new Error(`RPC error for ${method}: ${errorJson.error.message} (Code: ${errorJson.error.code}, HTTP Status: ${httpResponse.status}) Data: ${JSON.stringify(errorJson.error.data || {})}`);\n        } else if (!errorJson.jsonrpc) {\n          throw new Error(`HTTP error for ${method}! Status: ${httpResponse.status} ${httpResponse.statusText}. Response: ${errorBodyText}`);\n        }\n      } catch (e) {\n        if (e.message.startsWith(\"RPC error for\") || e.message.startsWith(\"HTTP error for\")) throw e;\n        throw new Error(`HTTP error for ${method}! Status: ${httpResponse.status} ${httpResponse.statusText}. Response: ${errorBodyText}`);\n      }\n    }\n    const rpcResponse = await httpResponse.json();\n    if (rpcResponse.id !== requestId) {\n      console.error(`CRITICAL: RPC response ID mismatch for method ${method}. Expected ${requestId}, got ${rpcResponse.id}. This may lead to incorrect response handling.`);\n    }\n    return rpcResponse;\n  }\n  /**\n   * Internal helper method to fetch the RPC service endpoint.\n   * @param url The URL to fetch.\n   * @param rpcRequest The JSON-RPC request to send.\n   * @param acceptHeader The Accept header to use.  Defaults to \"application/json\".\n   * @returns A Promise that resolves to the fetch HTTP response.\n   */\n  async _fetchRpc(url, rpcRequest, acceptHeader = \"application/json\") {\n    const requestInit = {\n      method: \"POST\",\n      headers: {\n        \"Content-Type\": \"application/json\",\n        \"Accept\": acceptHeader\n        // Expect JSON response for non-streaming requests\n      },\n      body: JSON.stringify(rpcRequest)\n    };\n    return this._fetch(url, requestInit);\n  }\n  /**\n   * Sends a message to the agent.\n   * The behavior (blocking/non-blocking) and push notification configuration\n   * are specified within the `params.configuration` object.\n   * Optionally, `params.message.contextId` or `params.message.taskId` can be provided.\n   * @param params The parameters for sending the message, including the message content and configuration.\n   * @returns A Promise resolving to SendMessageResponse, which can be a Message, Task, or an error.\n   */\n  async sendMessage(params) {\n    return this._postRpcRequest(\"message/send\", params);\n  }\n  /**\n   * Sends a message to the agent and streams back responses using Server-Sent Events (SSE).\n   * Push notification configuration can be specified in `params.configuration`.\n   * Optionally, `params.message.contextId` or `params.message.taskId` can be provided.\n   * Requires the agent to support streaming (`capabilities.streaming: true` in AgentCard).\n   * @param params The parameters for sending the message.\n   * @returns An AsyncGenerator yielding A2AStreamEventData (Message, Task, TaskStatusUpdateEvent, or TaskArtifactUpdateEvent).\n   * The generator throws an error if streaming is not supported or if an HTTP/SSE error occurs.\n   */\n  async *sendMessageStream(params) {\n    const agentCard = await this.agentCardPromise;\n    if (!agentCard.capabilities?.streaming) {\n      throw new Error(\"Agent does not support streaming (AgentCard.capabilities.streaming is not true).\");\n    }\n    const endpoint = await this._getServiceEndpoint();\n    const clientRequestId = this.requestIdCounter++;\n    const rpcRequest = {\n      // This is the initial JSON-RPC request to establish the stream\n      jsonrpc: \"2.0\",\n      method: \"message/stream\",\n      params,\n      id: clientRequestId\n    };\n    const response = await this._fetchRpc(endpoint, rpcRequest, \"text/event-stream\");\n    if (!response.ok) {\n      let errorBody = \"\";\n      try {\n        errorBody = await response.text();\n        const errorJson = JSON.parse(errorBody);\n        if (errorJson.error) {\n          throw new Error(`HTTP error establishing stream for message/stream: ${response.status} ${response.statusText}. RPC Error: ${errorJson.error.message} (Code: ${errorJson.error.code})`);\n        }\n      } catch (e) {\n        if (e.message.startsWith(\"HTTP error establishing stream\")) throw e;\n        throw new Error(`HTTP error establishing stream for message/stream: ${response.status} ${response.statusText}. Response: ${errorBody || \"(empty)\"}`);\n      }\n      throw new Error(`HTTP error establishing stream for message/stream: ${response.status} ${response.statusText}`);\n    }\n    if (!response.headers.get(\"Content-Type\")?.startsWith(\"text/event-stream\")) {\n      throw new Error(\"Invalid response Content-Type for SSE stream. Expected 'text/event-stream'.\");\n    }\n    yield* this._parseA2ASseStream(response, clientRequestId);\n  }\n  /**\n   * Sets or updates the push notification configuration for a given task.\n   * Requires the agent to support push notifications (`capabilities.pushNotifications: true` in AgentCard).\n   * @param params Parameters containing the taskId and the TaskPushNotificationConfig.\n   * @returns A Promise resolving to SetTaskPushNotificationConfigResponse.\n   */\n  async setTaskPushNotificationConfig(params) {\n    const agentCard = await this.agentCardPromise;\n    if (!agentCard.capabilities?.pushNotifications) {\n      throw new Error(\"Agent does not support push notifications (AgentCard.capabilities.pushNotifications is not true).\");\n    }\n    return this._postRpcRequest(\n      \"tasks/pushNotificationConfig/set\",\n      params\n    );\n  }\n  /**\n   * Gets the push notification configuration for a given task.\n   * @param params Parameters containing the taskId.\n   * @returns A Promise resolving to GetTaskPushNotificationConfigResponse.\n   */\n  async getTaskPushNotificationConfig(params) {\n    return this._postRpcRequest(\n      \"tasks/pushNotificationConfig/get\",\n      params\n    );\n  }\n  /**\n   * Lists the push notification configurations for a given task.\n   * @param params Parameters containing the taskId.\n   * @returns A Promise resolving to ListTaskPushNotificationConfigResponse.\n   */\n  async listTaskPushNotificationConfig(params) {\n    return this._postRpcRequest(\n      \"tasks/pushNotificationConfig/list\",\n      params\n    );\n  }\n  /**\n   * Deletes the push notification configuration for a given task.\n   * @param params Parameters containing the taskId and push notification configuration ID.\n   * @returns A Promise resolving to DeleteTaskPushNotificationConfigResponse.\n   */\n  async deleteTaskPushNotificationConfig(params) {\n    return this._postRpcRequest(\n      \"tasks/pushNotificationConfig/delete\",\n      params\n    );\n  }\n  /**\n   * Retrieves a task by its ID.\n   * @param params Parameters containing the taskId and optional historyLength.\n   * @returns A Promise resolving to GetTaskResponse, which contains the Task object or an error.\n   */\n  async getTask(params) {\n    return this._postRpcRequest(\"tasks/get\", params);\n  }\n  /**\n   * Cancels a task by its ID.\n   * @param params Parameters containing the taskId.\n   * @returns A Promise resolving to CancelTaskResponse, which contains the updated Task object or an error.\n   */\n  async cancelTask(params) {\n    return this._postRpcRequest(\"tasks/cancel\", params);\n  }\n  /**\n   * @template TExtensionParams The type of parameters for the custom extension method.\n   * @template TExtensionResponse The type of response expected from the custom extension method. \n   * This should extend JSONRPCResponse. This ensures the extension response is still a valid A2A response.\n   * @param method Custom JSON-RPC method defined in the AgentCard's extensions.\n   * @param params Extension paramters defined in the AgentCard's extensions.\n   * @returns A Promise that resolves to the RPC response.\n   */\n  async callExtensionMethod(method, params) {\n    return this._postRpcRequest(method, params);\n  }\n  /**\n   * Resubscribes to a task's event stream using Server-Sent Events (SSE).\n   * This is used if a previous SSE connection for an active task was broken.\n   * Requires the agent to support streaming (`capabilities.streaming: true` in AgentCard).\n   * @param params Parameters containing the taskId.\n   * @returns An AsyncGenerator yielding A2AStreamEventData (Message, Task, TaskStatusUpdateEvent, or TaskArtifactUpdateEvent).\n   */\n  async *resubscribeTask(params) {\n    const agentCard = await this.agentCardPromise;\n    if (!agentCard.capabilities?.streaming) {\n      throw new Error(\"Agent does not support streaming (required for tasks/resubscribe).\");\n    }\n    const endpoint = await this._getServiceEndpoint();\n    const clientRequestId = this.requestIdCounter++;\n    const rpcRequest = {\n      // Initial JSON-RPC request to establish the stream\n      jsonrpc: \"2.0\",\n      method: \"tasks/resubscribe\",\n      params,\n      id: clientRequestId\n    };\n    const response = await this._fetch(endpoint, {\n      method: \"POST\",\n      headers: {\n        \"Content-Type\": \"application/json\",\n        \"Accept\": \"text/event-stream\"\n      },\n      body: JSON.stringify(rpcRequest)\n    });\n    if (!response.ok) {\n      let errorBody = \"\";\n      try {\n        errorBody = await response.text();\n        const errorJson = JSON.parse(errorBody);\n        if (errorJson.error) {\n          throw new Error(`HTTP error establishing stream for tasks/resubscribe: ${response.status} ${response.statusText}. RPC Error: ${errorJson.error.message} (Code: ${errorJson.error.code})`);\n        }\n      } catch (e) {\n        if (e.message.startsWith(\"HTTP error establishing stream\")) throw e;\n        throw new Error(`HTTP error establishing stream for tasks/resubscribe: ${response.status} ${response.statusText}. Response: ${errorBody || \"(empty)\"}`);\n      }\n      throw new Error(`HTTP error establishing stream for tasks/resubscribe: ${response.status} ${response.statusText}`);\n    }\n    if (!response.headers.get(\"Content-Type\")?.startsWith(\"text/event-stream\")) {\n      throw new Error(\"Invalid response Content-Type for SSE stream on resubscribe. Expected 'text/event-stream'.\");\n    }\n    yield* this._parseA2ASseStream(response, clientRequestId);\n  }\n  /**\n   * Parses an HTTP response body as an A2A Server-Sent Event stream.\n   * Each 'data' field of an SSE event is expected to be a JSON-RPC 2.0 Response object,\n   * specifically a SendStreamingMessageResponse (or similar structure for resubscribe).\n   * @param response The HTTP Response object whose body is the SSE stream.\n   * @param originalRequestId The ID of the client's JSON-RPC request that initiated this stream.\n   * Used to validate the `id` in the streamed JSON-RPC responses.\n   * @returns An AsyncGenerator yielding the `result` field of each valid JSON-RPC success response from the stream.\n   */\n  async *_parseA2ASseStream(response, originalRequestId) {\n    if (!response.body) {\n      throw new Error(\"SSE response body is undefined. Cannot read stream.\");\n    }\n    const reader = response.body.pipeThrough(new TextDecoderStream()).getReader();\n    let buffer = \"\";\n    let eventDataBuffer = \"\";\n    try {\n      while (true) {\n        const { done, value } = await reader.read();\n        if (done) {\n          if (eventDataBuffer.trim()) {\n            const result = this._processSseEventData(eventDataBuffer, originalRequestId);\n            yield result;\n          }\n          break;\n        }\n        buffer += value;\n        let lineEndIndex;\n        while ((lineEndIndex = buffer.indexOf(\"\\n\")) >= 0) {\n          const line = buffer.substring(0, lineEndIndex).trim();\n          buffer = buffer.substring(lineEndIndex + 1);\n          if (line === \"\") {\n            if (eventDataBuffer) {\n              const result = this._processSseEventData(eventDataBuffer, originalRequestId);\n              yield result;\n              eventDataBuffer = \"\";\n            }\n          } else if (line.startsWith(\"data:\")) {\n            eventDataBuffer += line.substring(5).trimStart() + \"\\n\";\n          } else if (line.startsWith(\":\")) {\n          } else if (line.includes(\":\")) {\n          }\n        }\n      }\n    } catch (error) {\n      console.error(\"Error reading or parsing SSE stream:\", error.message);\n      throw error;\n    } finally {\n      reader.releaseLock();\n    }\n  }\n  /**\n   * Processes a single SSE event's data string, expecting it to be a JSON-RPC response.\n   * @param jsonData The string content from one or more 'data:' lines of an SSE event.\n   * @param originalRequestId The ID of the client's request that initiated the stream.\n   * @returns The `result` field of the parsed JSON-RPC success response.\n   * @throws Error if data is not valid JSON, not a valid JSON-RPC response, an error response, or ID mismatch.\n   */\n  _processSseEventData(jsonData, originalRequestId) {\n    if (!jsonData.trim()) {\n      throw new Error(\"Attempted to process empty SSE event data.\");\n    }\n    try {\n      const sseJsonRpcResponse = JSON.parse(jsonData.replace(/\\n$/, \"\"));\n      const a2aStreamResponse = sseJsonRpcResponse;\n      if (a2aStreamResponse.id !== originalRequestId) {\n        console.warn(`SSE Event's JSON-RPC response ID mismatch. Client request ID: ${originalRequestId}, event response ID: ${a2aStreamResponse.id}.`);\n      }\n      if (this.isErrorResponse(a2aStreamResponse)) {\n        const err = a2aStreamResponse.error;\n        throw new Error(`SSE event contained an error: ${err.message} (Code: ${err.code}) Data: ${JSON.stringify(err.data || {})}`);\n      }\n      if (!(\"result\" in a2aStreamResponse) || typeof a2aStreamResponse.result === \"undefined\") {\n        throw new Error(`SSE event JSON-RPC response is missing 'result' field. Data: ${jsonData}`);\n      }\n      const successResponse = a2aStreamResponse;\n      return successResponse.result;\n    } catch (e) {\n      if (e.message.startsWith(\"SSE event contained an error\") || e.message.startsWith(\"SSE event JSON-RPC response is missing 'result' field\")) {\n        throw e;\n      }\n      console.error(\"Failed to parse SSE event data string or unexpected JSON-RPC structure:\", jsonData, e);\n      throw new Error(`Failed to parse SSE event data: \"${jsonData.substring(0, 100)}...\". Original error: ${e.message}`);\n    }\n  }\n  isErrorResponse(response) {\n    return \"error\" in response;\n  }\n  ////////////////////////////////////////////////////////////////////////////////\n  // Functions used to support old A2AClient Constructor to be deprecated soon\n  // TODOs:\n  // * remove `agentCardPromise`, and just use agentCard initialized\n  // * _getServiceEndpoint can be made synchronous or deleted and accessed via\n  //   agentCard.url\n  // * getAgentCard changed to this.agentCard\n  // * delete resolveAgentCardUrl(), _fetchAndCacheAgentCard(),\n  //   agentCardPath from A2AClientOptions\n  ////////////////////////////////////////////////////////////////////////////////\n  /**\n   * Fetches the Agent Card from the agent's well-known URI and caches its service endpoint URL.\n   * This method is called by the constructor.\n   * @param agentBaseUrl The base URL of the A2A agent (e.g., https://agent.example.com)\n   * @param agentCardPath path to the agent card, defaults to .well-known/agent-card.json\n   * @returns A Promise that resolves to the AgentCard.\n   */\n  async _fetchAndCacheAgentCard(agentBaseUrl, agentCardPath) {\n    try {\n      const agentCardUrl = this.resolveAgentCardUrl(agentBaseUrl, agentCardPath);\n      const response = await this._fetch(agentCardUrl, {\n        headers: { \"Accept\": \"application/json\" }\n      });\n      if (!response.ok) {\n        throw new Error(`Failed to fetch Agent Card from ${agentCardUrl}: ${response.status} ${response.statusText}`);\n      }\n      const agentCard = await response.json();\n      if (!agentCard.url) {\n        throw new Error(\"Fetched Agent Card does not contain a valid 'url' for the service endpoint.\");\n      }\n      this.serviceEndpointUrl = agentCard.url;\n      return agentCard;\n    } catch (error) {\n      console.error(\"Error fetching or parsing Agent Card:\", error);\n      throw error;\n    }\n  }\n  /**\n  * Retrieves the Agent Card.\n  * If an `agentBaseUrl` is provided, it fetches the card from that specific URL.\n  * Otherwise, it returns the card fetched and cached during client construction.\n  * @param agentBaseUrl Optional. The base URL of the agent to fetch the card from.\n  * @param agentCardPath path to the agent card, defaults to .well-known/agent-card.json\n  * If provided, this will fetch a new card, not use the cached one from the constructor's URL.\n  * @returns A Promise that resolves to the AgentCard.\n  */\n  async getAgentCard(agentBaseUrl, agentCardPath) {\n    if (agentBaseUrl) {\n      const agentCardUrl = this.resolveAgentCardUrl(agentBaseUrl, agentCardPath);\n      const response = await this._fetch(agentCardUrl, {\n        headers: { \"Accept\": \"application/json\" }\n      });\n      if (!response.ok) {\n        throw new Error(`Failed to fetch Agent Card from ${agentCardUrl}: ${response.status} ${response.statusText}`);\n      }\n      return await response.json();\n    }\n    return this.agentCardPromise;\n  }\n  /**\n   * Determines the agent card URL based on the agent URL.\n   * @param agentBaseUrl The agent URL.\n   * @param agentCardPath Optional relative path to the agent card, defaults to .well-known/agent-card.json\n   */\n  resolveAgentCardUrl(agentBaseUrl, agentCardPath = _chunk_67JNQ6TZ_js__WEBPACK_IMPORTED_MODULE_0__.AGENT_CARD_PATH) {\n    return `${agentBaseUrl.replace(/\\/$/, \"\")}/${agentCardPath.replace(/^\\//, \"\")}`;\n  }\n  /**\n   * Gets the RPC service endpoint URL. Ensures the agent card has been fetched first.\n   * @returns A Promise that resolves to the service endpoint URL string.\n   */\n  async _getServiceEndpoint() {\n    if (this.serviceEndpointUrl) {\n      return this.serviceEndpointUrl;\n    }\n    await this.agentCardPromise;\n    if (!this.serviceEndpointUrl) {\n      throw new Error(\"Agent Card URL for RPC endpoint is not available. Fetching might have failed.\");\n    }\n    return this.serviceEndpointUrl;\n  }\n};\n\n// src/client/auth-handler.ts\nfunction createAuthenticatingFetchWithRetry(fetchImpl, authHandler) {\n  async function authFetch(url, init) {\n    const authHeaders = await authHandler.headers() || {};\n    const mergedInit = {\n      ...init || {},\n      headers: {\n        ...authHeaders,\n        ...init?.headers || {}\n      }\n    };\n    let response = await fetchImpl(url, mergedInit);\n    const updatedHeaders = await authHandler.shouldRetryWithHeaders(mergedInit, response);\n    if (updatedHeaders) {\n      const retryInit = {\n        ...init || {},\n        headers: {\n          ...updatedHeaders,\n          ...init?.headers || {}\n        }\n      };\n      response = await fetchImpl(url, retryInit);\n      if (response.ok && authHandler.onSuccessfulRetry) {\n        await authHandler.onSuccessfulRetry(updatedHeaders);\n      }\n    }\n    return response;\n  }\n  Object.setPrototypeOf(authFetch, Object.getPrototypeOf(fetchImpl));\n  Object.defineProperties(authFetch, Object.getOwnPropertyDescriptors(fetchImpl));\n  return authFetch;\n}\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGEyYS1qcy9zZGsvZGlzdC9jbGllbnQvaW5kZXguanMiLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBRThCOztBQUU5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5REFBeUQsYUFBYSxJQUFJLGlCQUFpQixFQUFFLG9CQUFvQjtBQUNqSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLDhEQUE4RCxhQUFhLG9CQUFvQixjQUFjO0FBQzdHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDViwyQ0FBMkMsT0FBTyxJQUFJLHlCQUF5QixTQUFTLHFCQUFxQixpQkFBaUIsb0JBQW9CLFVBQVUseUNBQXlDLEVBQUU7QUFDdk0sVUFBVTtBQUNWLDRDQUE0QyxPQUFPLFlBQVkscUJBQXFCLEVBQUUsd0JBQXdCLGNBQWMsY0FBYztBQUMxSTtBQUNBLFFBQVE7QUFDUjtBQUNBLDBDQUEwQyxPQUFPLFlBQVkscUJBQXFCLEVBQUUsd0JBQXdCLGNB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ZHVsZXMvQGEyYS1qcy9zZGsvZGlzdC9jbGllbnQvaW5kZXguanM/ZWVhMyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQge1xuICBBR0VOVF9DQVJEX1BBVEhcbn0gZnJvbSBcIi4uL2NodW5rLTY3Sk5RNlRaLmpzXCI7XG5cbi8vIHNyYy9jbGllbnQvY2xpZW50LnRzXG52YXIgQTJBQ2xpZW50ID0gY2xhc3MgX0EyQUNsaWVudCB7XG4gIGFnZW50Q2FyZFByb21pc2U7XG4gIHJlcXVlc3RJZENvdW50ZXIgPSAxO1xuICBzZXJ2aWNlRW5kcG9pbnRVcmw7XG4gIC8vIFRvIGJlIHBvcHVsYXRlZCBmcm9tIEFnZW50Q2FyZCBhZnRlciBmZXRjaGluZ1xuICBjdXN0b21GZXRjaEltcGw7XG4gIC8qKlxuICAgKiBDb25zdHJ1Y3RzIGFuIEEyQUNsaWVudCBpbnN0YW5jZSBmcm9tIGFuIEFnZW50Q2FyZC5cbiAgICogQHBhcmFtIGFnZW50Q2FyZCBUaGUgQWdlbnRDYXJkIG9iamVjdC5cbiAgICogQHBhcmFtIG9wdGlvbnMgT3B0aW9uYWwuIFRoZSBvcHRpb25zIGZvciB0aGUgQTJBQ2xpZW50IGluY2x1ZGluZyB0aGUgZmV0Y2gvYXV0aCBpbXBsZW1lbnRhdGlvbi5cbiAgICovXG4gIGNvbnN0cnVjdG9yKGFnZW50Q2FyZCwgb3B0aW9ucykge1xuICAgIHRoaXMuY3VzdG9tRmV0Y2hJbXBsID0gb3B0aW9ucz8uZmV0Y2hJbXBsO1xuICAgIGlmICh0eXBlb2YgYWdlbnRDYXJkID09PSBcInN0cmluZ1wiKSB7XG4gICAgICBjb25zb2xlLndhcm4oXCJXYXJuaW5nOiBDb25zdHJ1Y3RpbmcgQTJBQ2xpZW50IHdpdGggYSBVUkwgaXMgZGVwcmVjYXRlZC4gUGxlYXNlIHVzZSBBMkFDbGllbnQuZnJvbUNhcmRVcmwoKSBpbnN0ZWFkLlwiKTtcbiAgICAgIHRoaXMuYWdlbnRDYXJkUHJvbWlzZSA9IHRoaXMuX2ZldGNoQW5kQ2FjaGVBZ2VudENhcmQoYWdlbnRDYXJkLCBvcHRpb25zPy5hZ2VudENhcmRQYXRoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKCFhZ2VudENhcmQudXJsKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIlByb3ZpZGVkIEFnZW50IENhcmQgZG9lcyBub3QgY29udGFpbiBhIHZhbGlkICd1cmwnIGZvciB0aGUgc2VydmljZSBlbmRwb2ludC5cIik7XG4gICAgICB9XG4gICAgICB0aGlzLnNlcnZpY2VFbmRwb2ludFVybCA9IGFnZW50Q2FyZC51cmw7XG4gICAgICB0aGlzLmFnZW50Q2FyZFByb21pc2UgPSBQcm9taXNlLnJlc29sdmUoYWdlbnRDYXJkKTtcbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIER5bmFtaWNhbGx5IHJlc29sdmVzIHRoZSBmZXRjaCBpbXBsZW1lbnRhdGlvbiB0byB1c2UgZm9yIHJlcXVlc3RzLiBcbiAgICogUHJlZmVycyBhIGN1c3RvbSBpbXBsZW1lbnRhdGlvbiBpZiBwcm92aWRlZCwgb3RoZXJ3aXNlIGZhbGxzIGJhY2sgdG8gdGhlIGdsb2JhbCBmZXRjaC5cbiAgICogQHJldHVybnMgVGhlIGZldGNoIGltcGxlbWVudGF0aW9uLlxuICAgKiBAcGFyYW0gYXJncyBBcmd1bWVudHMgdG8gcGFzcyB0byB0aGUgZmV0Y2ggaW1wbGVtZW50YXRpb24uXG4gICAqIEB0aHJvd3MgSWYgbm8gZmV0Y2ggaW1wbGVtZW50YXRpb24gaXMgYXZhaWxhYmxlLlxuICAgKi9cbiAgX2ZldGNoKC4uLmFyZ3MpIHtcbiAgICBpZiAodGhpcy5jdXN0b21GZXRjaEltcGwpIHtcbiAgICAgIHJldHVybiB0aGlzLmN1c3RvbUZldGNoSW1wbCguLi5hcmdzKTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBmZXRjaCA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICByZXR1cm4gZmV0Y2goLi4uYXJncyk7XG4gICAgfVxuICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgIFwiQSBgZmV0Y2hgIGltcGxlbWVudGF0aW9uIHdhcyBub3QgcHJvdmlkZWQgYW5kIGlzIG5vdCBhdmFpbGFibGUgaW4gdGhlIGdsb2JhbCBzY29wZS4gUGxlYXNlIHByb3ZpZGUgYSBgZmV0Y2hJbXBsYCBpbiB0aGUgQTJBQ2xpZW50T3B0aW9ucy4gRm9yIGVhcmxpZXIgTm9kZS5qcyB2ZXJzaW9ucyAocHJlLXYxOCksIHlvdSBjYW4gdXNlIGEgbGlicmFyeSBsaWtlIGBub2RlLWZldGNoYC5cIlxuICAgICk7XG4gIH1cbiAgLyoqXG4gICAqIENyZWF0ZXMgYW4gQTJBQ2xpZW50IGluc3RhbmNlIGJ5IGZldGNoaW5nIHRoZSBBZ2VudENhcmQgZnJvbSBhIFVSTCB0aGVuIGNvbnN0cnVjdGluZyB0aGUgQTJBQ2xpZW50LlxuICAgKiBAcGFyYW0gYWdlbnRDYXJkVXJsIFRoZSBVUkwgb2YgdGhlIGFnZW50IGNhcmQuXG4gICAqIEBwYXJhbSBvcHRpb25zIE9wdGlvbmFsLiBUaGUgb3B0aW9ucyBmb3IgdGhlIEEyQUNsaWVudCBpbmNsdWRpbmcgdGhlIGZldGNoL2F1dGggaW1wbGVtZW50YXRpb24uXG4gICAqIEByZXR1cm5zIEEgUHJvbWlzZSB0aGF0IHJlc29sdmVzIHRvIGEgbmV3IEEyQUNsaWVudCBpbnN0YW5jZS5cbiAgICovXG4gIHN0YXRpYyBhc3luYyBmcm9tQ2FyZFVybChhZ2VudENhcmRVcmwsIG9wdGlvbnMpIHtcbiAgICBjb25zdCBmZXRjaEltcGwgPSBvcHRpb25zPy5mZXRjaEltcGw7XG4gICAgY29uc3QgcmVxdWVzdEluaXQgPSB7XG4gICAgICBoZWFkZXJzOiB7IFwiQWNjZXB0XCI6IFwiYXBwbGljYXRpb24vanNvblwiIH1cbiAgICB9O1xuICAgIGxldCByZXNwb25zZTtcbiAgICBpZiAoZmV0Y2hJbXBsKSB7XG4gICAgICByZXNwb25zZSA9IGF3YWl0IGZldGNoSW1wbChhZ2VudENhcmRVcmwsIHJlcXVlc3RJbml0KTtcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBmZXRjaCA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICByZXNwb25zZSA9IGF3YWl0IGZldGNoKGFnZW50Q2FyZFVybCwgcmVxdWVzdEluaXQpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgIFwiQSBgZmV0Y2hgIGltcGxlbWVudGF0aW9uIHdhcyBub3QgcHJvdmlkZWQgYW5kIGlzIG5vdCBhdmFpbGFibGUgaW4gdGhlIGdsb2JhbCBzY29wZS4gUGxlYXNlIHByb3ZpZGUgYSBgZmV0Y2hJbXBsYCBpbiB0aGUgQTJBQ2xpZW50T3B0aW9ucy4gRm9yIGVhcmxpZXIgTm9kZS5qcyB2ZXJzaW9ucyAocHJlLXYxOCksIHlvdSBjYW4gdXNlIGEgbGlicmFyeSBsaWtlIGBub2RlLWZldGNoYC5cIlxuICAgICAgKTtcbiAgICB9XG4gICAgaWYgKCFyZXNwb25zZS5vaykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBGYWlsZWQgdG8gZmV0Y2ggQWdlbnQgQ2FyZCBmcm9tICR7YWdlbnRDYXJkVXJsfTogJHtyZXNwb25zZS5zdGF0dXN9ICR7cmVzcG9uc2Uuc3RhdHVzVGV4dH1gKTtcbiAgICB9XG4gICAgbGV0IGFnZW50Q2FyZDtcbiAgICB0cnkge1xuICAgICAgYWdlbnRDYXJkID0gYXdhaXQgcmVzcG9uc2UuanNvbigpO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKFwiRmFpbGVkIHRvIHBhcnNlIEFnZW50IENhcmQgSlNPTjpcIiwgZXJyb3IpO1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBGYWlsZWQgdG8gcGFyc2UgQWdlbnQgQ2FyZCBKU09OIGZyb20gJHthZ2VudENhcmRVcmx9LiBPcmlnaW5hbCBlcnJvcjogJHtlcnJvci5tZXNzYWdlfWApO1xuICAgIH1cbiAgICByZXR1cm4gbmV3IF9BMkFDbGllbnQoYWdlbnRDYXJkLCBvcHRpb25zKTtcbiAgfVxuICAvKipcbiAgICogSGVscGVyIG1ldGhvZCB0byBtYWtlIGEgZ2VuZXJpYyBKU09OLVJQQyBQT1NUIHJlcXVlc3QuXG4gICAqIEBwYXJhbSBtZXRob2QgVGhlIFJQQyBtZXRob2QgbmFtZS5cbiAgICogQHBhcmFtIHBhcmFtcyBUaGUgcGFyYW1ldGVycyBmb3IgdGhlIFJQQyBtZXRob2QuXG4gICAqIEByZXR1cm5zIEEgUHJvbWlzZSB0aGF0IHJlc29sdmVzIHRvIHRoZSBSUEMgcmVzcG9uc2UuXG4gICAqL1xuICBhc3luYyBfcG9zdFJwY1JlcXVlc3QobWV0aG9kLCBwYXJhbXMpIHtcbiAgICBjb25zdCBlbmRwb2ludCA9IGF3YWl0IHRoaXMuX2dldFNlcnZpY2VFbmRwb2ludCgpO1xuICAgIGNvbnN0IHJlcXVlc3RJZCA9IHRoaXMucmVxdWVzdElkQ291bnRlcisrO1xuICAgIGNvbnN0IHJwY1JlcXVlc3QgPSB7XG4gICAgICBqc29ucnBjOiBcIjIuMFwiLFxuICAgICAgbWV0aG9kLFxuICAgICAgcGFyYW1zLFxuICAgICAgLy8gQ2FzdCBiZWNhdXNlIFRQYXJhbXMgc3RydWN0dXJlIHZhcmllcyBwZXIgbWV0aG9kXG4gICAgICBpZDogcmVxdWVzdElkXG4gICAgfTtcbiAgICBjb25zdCBodHRwUmVzcG9uc2UgPSBhd2FpdCB0aGlzLl9mZXRjaFJwYyhlbmRwb2ludCwgcnBjUmVxdWVzdCk7XG4gICAgaWYgKCFodHRwUmVzcG9uc2Uub2spIHtcbiAgICAgIGxldCBlcnJvckJvZHlUZXh0ID0gXCIoZW1wdHkgb3Igbm9uLUpTT04gcmVzcG9uc2UpXCI7XG4gICAgICB0cnkge1xuICAgICAgICBlcnJvckJvZHlUZXh0ID0gYXdhaXQgaHR0cFJlc3BvbnNlLnRleHQoKTtcbiAgICAgICAgY29uc3QgZXJyb3JKc29uID0gSlNPTi5wYXJzZShlcnJvckJvZHlUZXh0KTtcbiAgICAgICAgaWYgKGVycm9ySnNvbi5qc29ucnBjICYmIGVycm9ySnNvbi5lcnJvcikge1xuICAgICAgICAgIHJldHVybiBlcnJvckpzb247XG4gICAgICAgIH0gZWxzZSBpZiAoIWVycm9ySnNvbi5qc29ucnBjICYmIGVycm9ySnNvbi5lcnJvcikge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgUlBDIGVycm9yIGZvciAke21ldGhvZH06ICR7ZXJyb3JKc29uLmVycm9yLm1lc3NhZ2V9IChDb2RlOiAke2Vycm9ySnNvbi5lcnJvci5jb2RlfSwgSFRUUCBTdGF0dXM6ICR7aHR0cFJlc3BvbnNlLnN0YXR1c30pIERhdGE6ICR7SlNPTi5zdHJpbmdpZnkoZXJyb3JKc29uLmVycm9yLmRhdGEgfHwge30pfWApO1xuICAgICAgICB9IGVsc2UgaWYgKCFlcnJvckpzb24uanNvbnJwYykge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgSFRUUCBlcnJvciBmb3IgJHttZXRob2R9ISBTdGF0dXM6ICR7aHR0cFJlc3BvbnNlLnN0YXR1c30gJHtodHRwUmVzcG9uc2Uuc3RhdHVzVGV4dH0uIFJlc3BvbnNlOiAke2Vycm9yQm9keVRleHR9YCk7XG4gICAgICAgIH1cbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgaWYgKGUubWVzc2FnZS5zdGFydHNXaXRoKFwiUlBDIGVycm9yIGZvclwiKSB8fCBlLm1lc3NhZ2Uuc3RhcnRzV2l0aChcIkhUVFAgZXJyb3IgZm9yXCIpKSB0aHJvdyBlO1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEhUVFAgZXJyb3IgZm9yICR7bWV0aG9kfSEgU3RhdHVzOiAke2h0dHBSZXNwb25zZS5zdGF0dXN9ICR7aHR0cFJlc3BvbnNlLnN0YXR1c1RleHR9LiBSZXNwb25zZTogJHtlcnJvckJvZHlUZXh0fWApO1xuICAgICAgfVxuICAgIH1cbiAgICBjb25zdCBycGNSZXNwb25zZSA9IGF3YWl0IGh0dHBSZXNwb25zZS5qc29uKCk7XG4gICAgaWYgKHJwY1Jlc3BvbnNlLmlkICE9PSByZXF1ZXN0SWQpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoYENSSVRJQ0FMOiBSUEMgcmVzcG9uc2UgSUQgbWlzbWF0Y2ggZm9yIG1ldGhvZCAke21ldGhvZH0uIEV4cGVjdGVkICR7cmVxdWVzdElkfSwgZ290ICR7cnBjUmVzcG9uc2UuaWR9LiBUaGlzIG1heSBsZWFkIHRvIGluY29ycmVjdCByZXNwb25zZSBoYW5kbGluZy5gKTtcbiAgICB9XG4gICAgcmV0dXJuIHJwY1Jlc3BvbnNlO1xuICB9XG4gIC8qKlxuICAgKiBJbnRlcm5hbCBoZWxwZXIgbWV0aG9kIHRvIGZldGNoIHRoZSBSUEMgc2VydmljZSBlbmRwb2ludC5cbiAgICogQHBhcmFtIHVybCBUaGUgVVJMIHRvIGZldGNoLlxuICAgKiBAcGFyYW0gcnBjUmVxdWVzdCBUaGUgSlNPTi1SUEMgcmVxdWVzdCB0byBzZW5kLlxuICAgKiBAcGFyYW0gYWNjZXB0SGVhZGVyIFRoZSBBY2NlcHQgaGVhZGVyIHRvIHVzZS4gIERlZmF1bHRzIHRvIFwiYXBwbGljYXRpb24vanNvblwiLlxuICAgKiBAcmV0dXJucyBBIFByb21pc2UgdGhhdCByZXNvbHZlcyB0byB0aGUgZmV0Y2ggSFRUUCByZXNwb25zZS5cbiAgICovXG4gIGFzeW5jIF9mZXRjaFJwYyh1cmwsIHJwY1JlcXVlc3QsIGFjY2VwdEhlYWRlciA9IFwiYXBwbGljYXRpb24vanNvblwiKSB7XG4gICAgY29uc3QgcmVxdWVzdEluaXQgPSB7XG4gICAgICBtZXRob2Q6IFwiUE9TVFwiLFxuICAgICAgaGVhZGVyczoge1xuICAgICAgICBcIkNvbnRlbnQtVHlwZVwiOiBcImFwcGxpY2F0aW9uL2pzb25cIixcbiAgICAgICAgXCJBY2NlcHRcIjogYWNjZXB0SGVhZGVyXG4gICAgICAgIC8vIEV4cGVjdCBKU09OIHJlc3BvbnNlIGZvciBub24tc3RyZWFtaW5nIHJlcXVlc3RzXG4gICAgICB9LFxuICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkocnBjUmVxdWVzdClcbiAgICB9O1xuICAgIHJldHVybiB0aGlzLl9mZXRjaCh1cmwsIHJlcXVlc3RJbml0KTtcbiAgfVxuICAvKipcbiAgICogU2VuZHMgYSBtZXNzYWdlIHRvIHRoZSBhZ2VudC5cbiAgICogVGhlIGJlaGF2aW9yIChibG9ja2luZy9ub24tYmxvY2tpbmcpIGFuZCBwdXNoIG5vdGlmaWNhdGlvbiBjb25maWd1cmF0aW9uXG4gICAqIGFyZSBzcGVjaWZpZWQgd2l0aGluIHRoZSBgcGFyYW1zLmNvbmZpZ3VyYXRpb25gIG9iamVjdC5cbiAgICogT3B0aW9uYWxseSwgYHBhcmFtcy5tZXNzYWdlLmNvbnRleHRJZGAgb3IgYHBhcmFtcy5tZXNzYWdlLnRhc2tJZGAgY2FuIGJlIHByb3ZpZGVkLlxuICAgKiBAcGFyYW0gcGFyYW1zIFRoZSBwYXJhbWV0ZXJzIGZvciBzZW5kaW5nIHRoZSBtZXNzYWdlLCBpbmNsdWRpbmcgdGhlIG1lc3NhZ2UgY29udGVudCBhbmQgY29uZmlndXJhdGlvbi5cbiAgICogQHJldHVybnMgQSBQcm9taXNlIHJlc29sdmluZyB0byBTZW5kTWVzc2FnZVJlc3BvbnNlLCB3aGljaCBjYW4gYmUgYSBNZXNzYWdlLCBUYXNrLCBvciBhbiBlcnJvci5cbiAgICovXG4gIGFzeW5jIHNlbmRNZXNzYWdlKHBhcmFtcykge1xuICAgIHJldHVybiB0aGlzLl9wb3N0UnBjUmVxdWVzdChcIm1lc3NhZ2Uvc2VuZFwiLCBwYXJhbXMpO1xuICB9XG4gIC8qKlxuICAgKiBTZW5kcyBhIG1lc3NhZ2UgdG8gdGhlIGFnZW50IGFuZCBzdHJlYW1zIGJhY2sgcmVzcG9uc2VzIHVzaW5nIFNlcnZlci1TZW50IEV2ZW50cyAoU1NFKS5cbiAgICogUHVzaCBub3RpZmljYXRpb24gY29uZmlndXJhdGlvbiBjYW4gYmUgc3BlY2lmaWVkIGluIGBwYXJhbXMuY29uZmlndXJhdGlvbmAuXG4gICAqIE9wdGlvbmFsbHksIGBwYXJhbXMubWVzc2FnZS5jb250ZXh0SWRgIG9yIGBwYXJhbXMubWVzc2FnZS50YXNrSWRgIGNhbiBiZSBwcm92aWRlZC5cbiAgICogUmVxdWlyZXMgdGhlIGFnZW50IHRvIHN1cHBvcnQgc3RyZWFtaW5nIChgY2FwYWJpbGl0aWVzLnN0cmVhbWluZzogdHJ1ZWAgaW4gQWdlbnRDYXJkKS5cbiAgICogQHBhcmFtIHBhcmFtcyBUaGUgcGFyYW1ldGVycyBmb3Igc2VuZGluZyB0aGUgbWVzc2FnZS5cbiAgICogQHJldHVybnMgQW4gQXN5bmNHZW5lcmF0b3IgeWllbGRpbmcgQTJBU3RyZWFtRXZlbnREYXRhIChNZXNzYWdlLCBUYXNrLCBUYXNrU3RhdHVzVXBkYXRlRXZlbnQsIG9yIFRhc2tBcnRpZmFjdFVwZGF0ZUV2ZW50KS5cbiAgICogVGhlIGdlbmVyYXRvciB0aHJvd3MgYW4gZXJyb3IgaWYgc3RyZWFtaW5nIGlzIG5vdCBzdXBwb3J0ZWQgb3IgaWYgYW4gSFRUUC9TU0UgZXJyb3Igb2NjdXJzLlxuICAgKi9cbiAgYXN5bmMgKnNlbmRNZXNzYWdlU3RyZWFtKHBhcmFtcykge1xuICAgIGNvbnN0IGFnZW50Q2FyZCA9IGF3YWl0IHRoaXMuYWdlbnRDYXJkUHJvbWlzZTtcbiAgICBpZiAoIWFnZW50Q2FyZC5jYXBhYmlsaXRpZXM/LnN0cmVhbWluZykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQWdlbnQgZG9lcyBub3Qgc3VwcG9ydCBzdHJlYW1pbmcgKEFnZW50Q2FyZC5jYXBhYmlsaXRpZXMuc3RyZWFtaW5nIGlzIG5vdCB0cnVlKS5cIik7XG4gICAgfVxuICAgIGNvbnN0IGVuZHBvaW50ID0gYXdhaXQgdGhpcy5fZ2V0U2VydmljZUVuZHBvaW50KCk7XG4gICAgY29uc3QgY2xpZW50UmVxdWVzdElkID0gdGhpcy5yZXF1ZXN0SWRDb3VudGVyKys7XG4gICAgY29uc3QgcnBjUmVxdWVzdCA9IHtcbiAgICAgIC8vIFRoaXMgaXMgdGhlIGluaXRpYWwgSlNPTi1SUEMgcmVxdWVzdCB0byBlc3RhYmxpc2ggdGhlIHN0cmVhbVxuICAgICAganNvbnJwYzogXCIyLjBcIixcbiAgICAgIG1ldGhvZDogXCJtZXNzYWdlL3N0cmVhbVwiLFxuICAgICAgcGFyYW1zLFxuICAgICAgaWQ6IGNsaWVudFJlcXVlc3RJZFxuICAgIH07XG4gICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLl9mZXRjaFJwYyhlbmRwb2ludCwgcnBjUmVxdWVzdCwgXCJ0ZXh0L2V2ZW50LXN0cmVhbVwiKTtcbiAgICBpZiAoIXJlc3BvbnNlLm9rKSB7XG4gICAgICBsZXQgZXJyb3JCb2R5ID0gXCJcIjtcbiAgICAgIHRyeSB7XG4gICAgICAgIGVycm9yQm9keSA9IGF3YWl0IHJlc3BvbnNlLnRleHQoKTtcbiAgICAgICAgY29uc3QgZXJyb3JKc29uID0gSlNPTi5wYXJzZShlcnJvckJvZHkpO1xuICAgICAgICBpZiAoZXJyb3JKc29uLmVycm9yKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBIVFRQIGVycm9yIGVzdGFibGlzaGluZyBzdHJlYW0gZm9yIG1lc3NhZ2Uvc3RyZWFtOiAke3Jlc3BvbnNlLnN0YXR1c30gJHtyZXNwb25zZS5zdGF0dXNUZXh0fS4gUlBDIEVycm9yOiAke2Vycm9ySnNvbi5lcnJvci5tZXNzYWdlfSAoQ29kZTogJHtlcnJvckpzb24uZXJyb3IuY29kZX0pYCk7XG4gICAgICAgIH1cbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgaWYgKGUubWVzc2FnZS5zdGFydHNXaXRoKFwiSFRUUCBlcnJvciBlc3RhYmxpc2hpbmcgc3RyZWFtXCIpKSB0aHJvdyBlO1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEhUVFAgZXJyb3IgZXN0YWJsaXNoaW5nIHN0cmVhbSBmb3IgbWVzc2FnZS9zdHJlYW06ICR7cmVzcG9uc2Uuc3RhdHVzfSAke3Jlc3BvbnNlLnN0YXR1c1RleHR9LiBSZXNwb25zZTogJHtlcnJvckJvZHkgfHwgXCIoZW1wdHkpXCJ9YCk7XG4gICAgICB9XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYEhUVFAgZXJyb3IgZXN0YWJsaXNoaW5nIHN0cmVhbSBmb3IgbWVzc2FnZS9zdHJlYW06ICR7cmVzcG9uc2Uuc3RhdHVzfSAke3Jlc3BvbnNlLnN0YXR1c1RleHR9YCk7XG4gICAgfVxuICAgIGlmICghcmVzcG9uc2UuaGVhZGVycy5nZXQoXCJDb250ZW50LVR5cGVcIik/LnN0YXJ0c1dpdGgoXCJ0ZXh0L2V2ZW50LXN0cmVhbVwiKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCByZXNwb25zZSBDb250ZW50LVR5cGUgZm9yIFNTRSBzdHJlYW0uIEV4cGVjdGVkICd0ZXh0L2V2ZW50LXN0cmVhbScuXCIpO1xuICAgIH1cbiAgICB5aWVsZCogdGhpcy5fcGFyc2VBMkFTc2VTdHJlYW0ocmVzcG9uc2UsIGNsaWVudFJlcXVlc3RJZCk7XG4gIH1cbiAgLyoqXG4gICAqIFNldHMgb3IgdXBkYXRlcyB0aGUgcHVzaCBub3RpZmljYXRpb24gY29uZmlndXJhdGlvbiBmb3IgYSBnaXZlbiB0YXNrLlxuICAgKiBSZXF1aXJlcyB0aGUgYWdlbnQgdG8gc3VwcG9ydCBwdXNoIG5vdGlmaWNhdGlvbnMgKGBjYXBhYmlsaXRpZXMucHVzaE5vdGlmaWNhdGlvbnM6IHRydWVgIGluIEFnZW50Q2FyZCkuXG4gICAqIEBwYXJhbSBwYXJhbXMgUGFyYW1ldGVycyBjb250YWluaW5nIHRoZSB0YXNrSWQgYW5kIHRoZSBUYXNrUHVzaE5vdGlmaWNhdGlvbkNvbmZpZy5cbiAgICogQHJldHVybnMgQSBQcm9taXNlIHJlc29sdmluZyB0byBTZXRUYXNrUHVzaE5vdGlmaWNhdGlvbkNvbmZpZ1Jlc3BvbnNlLlxuICAgKi9cbiAgYXN5bmMgc2V0VGFza1B1c2hOb3RpZmljYXRpb25Db25maWcocGFyYW1zKSB7XG4gICAgY29uc3QgYWdlbnRDYXJkID0gYXdhaXQgdGhpcy5hZ2VudENhcmRQcm9taXNlO1xuICAgIGlmICghYWdlbnRDYXJkLmNhcGFiaWxpdGllcz8ucHVzaE5vdGlmaWNhdGlvbnMpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkFnZW50IGRvZXMgbm90IHN1cHBvcnQgcHVzaCBub3RpZmljYXRpb25zIChBZ2VudENhcmQuY2FwYWJpbGl0aWVzLnB1c2hOb3RpZmljYXRpb25zIGlzIG5vdCB0cnVlKS5cIik7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLl9wb3N0UnBjUmVxdWVzdChcbiAgICAgIFwidGFza3MvcHVzaE5vdGlmaWNhdGlvbkNvbmZpZy9zZXRcIixcbiAgICAgIHBhcmFtc1xuICAgICk7XG4gIH1cbiAgLyoqXG4gICAqIEdldHMgdGhlIHB1c2ggbm90aWZpY2F0aW9uIGNvbmZpZ3VyYXRpb24gZm9yIGEgZ2l2ZW4gdGFzay5cbiAgICogQHBhcmFtIHBhcmFtcyBQYXJhbWV0ZXJzIGNvbnRhaW5pbmcgdGhlIHRhc2tJZC5cbiAgICogQHJldHVybnMgQSBQcm9taXNlIHJlc29sdmluZyB0byBHZXRUYXNrUHVzaE5vdGlmaWNhdGlvbkNvbmZpZ1Jlc3BvbnNlLlxuICAgKi9cbiAgYXN5bmMgZ2V0VGFza1B1c2hOb3RpZmljYXRpb25Db25maWcocGFyYW1zKSB7XG4gICAgcmV0dXJuIHRoaXMuX3Bvc3RScGNSZXF1ZXN0KFxuICAgICAgXCJ0YXNrcy9wdXNoTm90aWZpY2F0aW9uQ29uZmlnL2dldFwiLFxuICAgICAgcGFyYW1zXG4gICAgKTtcbiAgfVxuICAvKipcbiAgICogTGlzdHMgdGhlIHB1c2ggbm90aWZpY2F0aW9uIGNvbmZpZ3VyYXRpb25zIGZvciBhIGdpdmVuIHRhc2suXG4gICAqIEBwYXJhbSBwYXJhbXMgUGFyYW1ldGVycyBjb250YWluaW5nIHRoZSB0YXNrSWQuXG4gICAqIEByZXR1cm5zIEEgUHJvbWlzZSByZXNvbHZpbmcgdG8gTGlzdFRhc2tQdXNoTm90aWZpY2F0aW9uQ29uZmlnUmVzcG9uc2UuXG4gICAqL1xuICBhc3luYyBsaXN0VGFza1B1c2hOb3RpZmljYXRpb25Db25maWcocGFyYW1zKSB7XG4gICAgcmV0dXJuIHRoaXMuX3Bvc3RScGNSZXF1ZXN0KFxuICAgICAgXCJ0YXNrcy9wdXNoTm90aWZpY2F0aW9uQ29uZmlnL2xpc3RcIixcbiAgICAgIHBhcmFtc1xuICAgICk7XG4gIH1cbiAgLyoqXG4gICAqIERlbGV0ZXMgdGhlIHB1c2ggbm90aWZpY2F0aW9uIGNvbmZpZ3VyYXRpb24gZm9yIGEgZ2l2ZW4gdGFzay5cbiAgICogQHBhcmFtIHBhcmFtcyBQYXJhbWV0ZXJzIGNvbnRhaW5pbmcgdGhlIHRhc2tJZCBhbmQgcHVzaCBub3RpZmljYXRpb24gY29uZmlndXJhdGlvbiBJRC5cbiAgICogQHJldHVybnMgQSBQcm9taXNlIHJlc29sdmluZyB0byBEZWxldGVUYXNrUHVzaE5vdGlmaWNhdGlvbkNvbmZpZ1Jlc3BvbnNlLlxuICAgKi9cbiAgYXN5bmMgZGVsZXRlVGFza1B1c2hOb3RpZmljYXRpb25Db25maWcocGFyYW1zKSB7XG4gICAgcmV0dXJuIHRoaXMuX3Bvc3RScGNSZXF1ZXN0KFxuICAgICAgXCJ0YXNrcy9wdXNoTm90aWZpY2F0aW9uQ29uZmlnL2RlbGV0ZVwiLFxuICAgICAgcGFyYW1zXG4gICAgKTtcbiAgfVxuICAvKipcbiAgICogUmV0cmlldmVzIGEgdGFzayBieSBpdHMgSUQuXG4gICAqIEBwYXJhbSBwYXJhbXMgUGFyYW1ldGVycyBjb250YWluaW5nIHRoZSB0YXNrSWQgYW5kIG9wdGlvbmFsIGhpc3RvcnlMZW5ndGguXG4gICAqIEByZXR1cm5zIEEgUHJvbWlzZSByZXNvbHZpbmcgdG8gR2V0VGFza1Jlc3BvbnNlLCB3aGljaCBjb250YWlucyB0aGUgVGFzayBvYmplY3Qgb3IgYW4gZXJyb3IuXG4gICAqL1xuICBhc3luYyBnZXRUYXNrKHBhcmFtcykge1xuICAgIHJldHVybiB0aGlzLl9wb3N0UnBjUmVxdWVzdChcInRhc2tzL2dldFwiLCBwYXJhbXMpO1xuICB9XG4gIC8qKlxuICAgKiBDYW5jZWxzIGEgdGFzayBieSBpdHMgSUQuXG4gICAqIEBwYXJhbSBwYXJhbXMgUGFyYW1ldGVycyBjb250YWluaW5nIHRoZSB0YXNrSWQuXG4gICAqIEByZXR1cm5zIEEgUHJvbWlzZSByZXNvbHZpbmcgdG8gQ2FuY2VsVGFza1Jlc3BvbnNlLCB3aGljaCBjb250YWlucyB0aGUgdXBkYXRlZCBUYXNrIG9iamVjdCBvciBhbiBlcnJvci5cbiAgICovXG4gIGFzeW5jIGNhbmNlbFRhc2socGFyYW1zKSB7XG4gICAgcmV0dXJuIHRoaXMuX3Bvc3RScGNSZXF1ZXN0KFwidGFza3MvY2FuY2VsXCIsIHBhcmFtcyk7XG4gIH1cbiAgLyoqXG4gICAqIEB0ZW1wbGF0ZSBURXh0ZW5zaW9uUGFyYW1zIFRoZSB0eXBlIG9mIHBhcmFtZXRlcnMgZm9yIHRoZSBjdXN0b20gZXh0ZW5zaW9uIG1ldGhvZC5cbiAgICogQHRlbXBsYXRlIFRFeHRlbnNpb25SZXNwb25zZSBUaGUgdHlwZSBvZiByZXNwb25zZSBleHBlY3RlZCBmcm9tIHRoZSBjdXN0b20gZXh0ZW5zaW9uIG1ldGhvZC4gXG4gICAqIFRoaXMgc2hvdWxkIGV4dGVuZCBKU09OUlBDUmVzcG9uc2UuIFRoaXMgZW5zdXJlcyB0aGUgZXh0ZW5zaW9uIHJlc3BvbnNlIGlzIHN0aWxsIGEgdmFsaWQgQTJBIHJlc3BvbnNlLlxuICAgKiBAcGFyYW0gbWV0aG9kIEN1c3RvbSBKU09OLVJQQyBtZXRob2QgZGVmaW5lZCBpbiB0aGUgQWdlbnRDYXJkJ3MgZXh0ZW5zaW9ucy5cbiAgICogQHBhcmFtIHBhcmFtcyBFeHRlbnNpb24gcGFyYW10ZXJzIGRlZmluZWQgaW4gdGhlIEFnZW50Q2FyZCdzIGV4dGVuc2lvbnMuXG4gICAqIEByZXR1cm5zIEEgUHJvbWlzZSB0aGF0IHJlc29sdmVzIHRvIHRoZSBSUEMgcmVzcG9uc2UuXG4gICAqL1xuICBhc3luYyBjYWxsRXh0ZW5zaW9uTWV0aG9kKG1ldGhvZCwgcGFyYW1zKSB7XG4gICAgcmV0dXJuIHRoaXMuX3Bvc3RScGNSZXF1ZXN0KG1ldGhvZCwgcGFyYW1zKTtcbiAgfVxuICAvKipcbiAgICogUmVzdWJzY3JpYmVzIHRvIGEgdGFzaydzIGV2ZW50IHN0cmVhbSB1c2luZyBTZXJ2ZXItU2VudCBFdmVudHMgKFNTRSkuXG4gICAqIFRoaXMgaXMgdXNlZCBpZiBhIHByZXZpb3VzIFNTRSBjb25uZWN0aW9uIGZvciBhbiBhY3RpdmUgdGFzayB3YXMgYnJva2VuLlxuICAgKiBSZXF1aXJlcyB0aGUgYWdlbnQgdG8gc3VwcG9ydCBzdHJlYW1pbmcgKGBjYXBhYmlsaXRpZXMuc3RyZWFtaW5nOiB0cnVlYCBpbiBBZ2VudENhcmQpLlxuICAgKiBAcGFyYW0gcGFyYW1zIFBhcmFtZXRlcnMgY29udGFpbmluZyB0aGUgdGFza0lkLlxuICAgKiBAcmV0dXJucyBBbiBBc3luY0dlbmVyYXRvciB5aWVsZGluZyBBMkFTdHJlYW1FdmVudERhdGEgKE1lc3NhZ2UsIFRhc2ssIFRhc2tTdGF0dXNVcGRhdGVFdmVudCwgb3IgVGFza0FydGlmYWN0VXBkYXRlRXZlbnQpLlxuICAgKi9cbiAgYXN5bmMgKnJlc3Vic2NyaWJlVGFzayhwYXJhbXMpIHtcbiAgICBjb25zdCBhZ2VudENhcmQgPSBhd2FpdCB0aGlzLmFnZW50Q2FyZFByb21pc2U7XG4gICAgaWYgKCFhZ2VudENhcmQuY2FwYWJpbGl0aWVzPy5zdHJlYW1pbmcpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkFnZW50IGRvZXMgbm90IHN1cHBvcnQgc3RyZWFtaW5nIChyZXF1aXJlZCBmb3IgdGFza3MvcmVzdWJzY3JpYmUpLlwiKTtcbiAgICB9XG4gICAgY29uc3QgZW5kcG9pbnQgPSBhd2FpdCB0aGlzLl9nZXRTZXJ2aWNlRW5kcG9pbnQoKTtcbiAgICBjb25zdCBjbGllbnRSZXF1ZXN0SWQgPSB0aGlzLnJlcXVlc3RJZENvdW50ZXIrKztcbiAgICBjb25zdCBycGNSZXF1ZXN0ID0ge1xuICAgICAgLy8gSW5pdGlhbCBKU09OLVJQQyByZXF1ZXN0IHRvIGVzdGFibGlzaCB0aGUgc3RyZWFtXG4gICAgICBqc29ucnBjOiBcIjIuMFwiLFxuICAgICAgbWV0aG9kOiBcInRhc2tzL3Jlc3Vic2NyaWJlXCIsXG4gICAgICBwYXJhbXMsXG4gICAgICBpZDogY2xpZW50UmVxdWVzdElkXG4gICAgfTtcbiAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHRoaXMuX2ZldGNoKGVuZHBvaW50LCB7XG4gICAgICBtZXRob2Q6IFwiUE9TVFwiLFxuICAgICAgaGVhZGVyczoge1xuICAgICAgICBcIkNvbnRlbnQtVHlwZVwiOiBcImFwcGxpY2F0aW9uL2pzb25cIixcbiAgICAgICAgXCJBY2NlcHRcIjogXCJ0ZXh0L2V2ZW50LXN0cmVhbVwiXG4gICAgICB9LFxuICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkocnBjUmVxdWVzdClcbiAgICB9KTtcbiAgICBpZiAoIXJlc3BvbnNlLm9rKSB7XG4gICAgICBsZXQgZXJyb3JCb2R5ID0gXCJcIjtcbiAgICAgIHRyeSB7XG4gICAgICAgIGVycm9yQm9keSA9IGF3YWl0IHJlc3BvbnNlLnRleHQoKTtcbiAgICAgICAgY29uc3QgZXJyb3JKc29uID0gSlNPTi5wYXJzZShlcnJvckJvZHkpO1xuICAgICAgICBpZiAoZXJyb3JKc29uLmVycm9yKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBIVFRQIGVycm9yIGVzdGFibGlzaGluZyBzdHJlYW0gZm9yIHRhc2tzL3Jlc3Vic2NyaWJlOiAke3Jlc3BvbnNlLnN0YXR1c30gJHtyZXNwb25zZS5zdGF0dXNUZXh0fS4gUlBDIEVycm9yOiAke2Vycm9ySnNvbi5lcnJvci5tZXNzYWdlfSAoQ29kZTogJHtlcnJvckpzb24uZXJyb3IuY29kZX0pYCk7XG4gICAgICAgIH1cbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgaWYgKGUubWVzc2FnZS5zdGFydHNXaXRoKFwiSFRUUCBlcnJvciBlc3RhYmxpc2hpbmcgc3RyZWFtXCIpKSB0aHJvdyBlO1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEhUVFAgZXJyb3IgZXN0YWJsaXNoaW5nIHN0cmVhbSBmb3IgdGFza3MvcmVzdWJzY3JpYmU6ICR7cmVzcG9uc2Uuc3RhdHVzfSAke3Jlc3BvbnNlLnN0YXR1c1RleHR9LiBSZXNwb25zZTogJHtlcnJvckJvZHkgfHwgXCIoZW1wdHkpXCJ9YCk7XG4gICAgICB9XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYEhUVFAgZXJyb3IgZXN0YWJsaXNoaW5nIHN0cmVhbSBmb3IgdGFza3MvcmVzdWJzY3JpYmU6ICR7cmVzcG9uc2Uuc3RhdHVzfSAke3Jlc3BvbnNlLnN0YXR1c1RleHR9YCk7XG4gICAgfVxuICAgIGlmICghcmVzcG9uc2UuaGVhZGVycy5nZXQoXCJDb250ZW50LVR5cGVcIik/LnN0YXJ0c1dpdGgoXCJ0ZXh0L2V2ZW50LXN0cmVhbVwiKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCByZXNwb25zZSBDb250ZW50LVR5cGUgZm9yIFNTRSBzdHJlYW0gb24gcmVzdWJzY3JpYmUuIEV4cGVjdGVkICd0ZXh0L2V2ZW50LXN0cmVhbScuXCIpO1xuICAgIH1cbiAgICB5aWVsZCogdGhpcy5fcGFyc2VBMkFTc2VTdHJlYW0ocmVzcG9uc2UsIGNsaWVudFJlcXVlc3RJZCk7XG4gIH1cbiAgLyoqXG4gICAqIFBhcnNlcyBhbiBIVFRQIHJlc3BvbnNlIGJvZHkgYXMgYW4gQTJBIFNlcnZlci1TZW50IEV2ZW50IHN0cmVhbS5cbiAgICogRWFjaCAnZGF0YScgZmllbGQgb2YgYW4gU1NFIGV2ZW50IGlzIGV4cGVjdGVkIHRvIGJlIGEgSlNPTi1SUEMgMi4wIFJlc3BvbnNlIG9iamVjdCxcbiAgICogc3BlY2lmaWNhbGx5IGEgU2VuZFN0cmVhbWluZ01lc3NhZ2VSZXNwb25zZSAob3Igc2ltaWxhciBzdHJ1Y3R1cmUgZm9yIHJlc3Vic2NyaWJlKS5cbiAgICogQHBhcmFtIHJlc3BvbnNlIFRoZSBIVFRQIFJlc3BvbnNlIG9iamVjdCB3aG9zZSBib2R5IGlzIHRoZSBTU0Ugc3RyZWFtLlxuICAgKiBAcGFyYW0gb3JpZ2luYWxSZXF1ZXN0SWQgVGhlIElEIG9mIHRoZSBjbGllbnQncyBKU09OLVJQQyByZXF1ZXN0IHRoYXQgaW5pdGlhdGVkIHRoaXMgc3RyZWFtLlxuICAgKiBVc2VkIHRvIHZhbGlkYXRlIHRoZSBgaWRgIGluIHRoZSBzdHJlYW1lZCBKU09OLVJQQyByZXNwb25zZXMuXG4gICAqIEByZXR1cm5zIEFuIEFzeW5jR2VuZXJhdG9yIHlpZWxkaW5nIHRoZSBgcmVzdWx0YCBmaWVsZCBvZiBlYWNoIHZhbGlkIEpTT04tUlBDIHN1Y2Nlc3MgcmVzcG9uc2UgZnJvbSB0aGUgc3RyZWFtLlxuICAgKi9cbiAgYXN5bmMgKl9wYXJzZUEyQVNzZVN0cmVhbShyZXNwb25zZSwgb3JpZ2luYWxSZXF1ZXN0SWQpIHtcbiAgICBpZiAoIXJlc3BvbnNlLmJvZHkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIlNTRSByZXNwb25zZSBib2R5IGlzIHVuZGVmaW5lZC4gQ2Fubm90IHJlYWQgc3RyZWFtLlwiKTtcbiAgICB9XG4gICAgY29uc3QgcmVhZGVyID0gcmVzcG9uc2UuYm9keS5waXBlVGhyb3VnaChuZXcgVGV4dERlY29kZXJTdHJlYW0oKSkuZ2V0UmVhZGVyKCk7XG4gICAgbGV0IGJ1ZmZlciA9IFwiXCI7XG4gICAgbGV0IGV2ZW50RGF0YUJ1ZmZlciA9IFwiXCI7XG4gICAgdHJ5IHtcbiAgICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICAgIGNvbnN0IHsgZG9uZSwgdmFsdWUgfSA9IGF3YWl0IHJlYWRlci5yZWFkKCk7XG4gICAgICAgIGlmIChkb25lKSB7XG4gICAgICAgICAgaWYgKGV2ZW50RGF0YUJ1ZmZlci50cmltKCkpIHtcbiAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IHRoaXMuX3Byb2Nlc3NTc2VFdmVudERhdGEoZXZlbnREYXRhQnVmZmVyLCBvcmlnaW5hbFJlcXVlc3RJZCk7XG4gICAgICAgICAgICB5aWVsZCByZXN1bHQ7XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGJ1ZmZlciArPSB2YWx1ZTtcbiAgICAgICAgbGV0IGxpbmVFbmRJbmRleDtcbiAgICAgICAgd2hpbGUgKChsaW5lRW5kSW5kZXggPSBidWZmZXIuaW5kZXhPZihcIlxcblwiKSkgPj0gMCkge1xuICAgICAgICAgIGNvbnN0IGxpbmUgPSBidWZmZXIuc3Vic3RyaW5nKDAsIGxpbmVFbmRJbmRleCkudHJpbSgpO1xuICAgICAgICAgIGJ1ZmZlciA9IGJ1ZmZlci5zdWJzdHJpbmcobGluZUVuZEluZGV4ICsgMSk7XG4gICAgICAgICAgaWYgKGxpbmUgPT09IFwiXCIpIHtcbiAgICAgICAgICAgIGlmIChldmVudERhdGFCdWZmZXIpIHtcbiAgICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gdGhpcy5fcHJvY2Vzc1NzZUV2ZW50RGF0YShldmVudERhdGFCdWZmZXIsIG9yaWdpbmFsUmVxdWVzdElkKTtcbiAgICAgICAgICAgICAgeWllbGQgcmVzdWx0O1xuICAgICAgICAgICAgICBldmVudERhdGFCdWZmZXIgPSBcIlwiO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSBpZiAobGluZS5zdGFydHNXaXRoKFwiZGF0YTpcIikpIHtcbiAgICAgICAgICAgIGV2ZW50RGF0YUJ1ZmZlciArPSBsaW5lLnN1YnN0cmluZyg1KS50cmltU3RhcnQoKSArIFwiXFxuXCI7XG4gICAgICAgICAgfSBlbHNlIGlmIChsaW5lLnN0YXJ0c1dpdGgoXCI6XCIpKSB7XG4gICAgICAgICAgfSBlbHNlIGlmIChsaW5lLmluY2x1ZGVzKFwiOlwiKSkge1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKFwiRXJyb3IgcmVhZGluZyBvciBwYXJzaW5nIFNTRSBzdHJlYW06XCIsIGVycm9yLm1lc3NhZ2UpO1xuICAgICAgdGhyb3cgZXJyb3I7XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIHJlYWRlci5yZWxlYXNlTG9jaygpO1xuICAgIH1cbiAgfVxuICAvKipcbiAgICogUHJvY2Vzc2VzIGEgc2luZ2xlIFNTRSBldmVudCdzIGRhdGEgc3RyaW5nLCBleHBlY3RpbmcgaXQgdG8gYmUgYSBKU09OLVJQQyByZXNwb25zZS5cbiAgICogQHBhcmFtIGpzb25EYXRhIFRoZSBzdHJpbmcgY29udGVudCBmcm9tIG9uZSBvciBtb3JlICdkYXRhOicgbGluZXMgb2YgYW4gU1NFIGV2ZW50LlxuICAgKiBAcGFyYW0gb3JpZ2luYWxSZXF1ZXN0SWQgVGhlIElEIG9mIHRoZSBjbGllbnQncyByZXF1ZXN0IHRoYXQgaW5pdGlhdGVkIHRoZSBzdHJlYW0uXG4gICAqIEByZXR1cm5zIFRoZSBgcmVzdWx0YCBmaWVsZCBvZiB0aGUgcGFyc2VkIEpTT04tUlBDIHN1Y2Nlc3MgcmVzcG9uc2UuXG4gICAqIEB0aHJvd3MgRXJyb3IgaWYgZGF0YSBpcyBub3QgdmFsaWQgSlNPTiwgbm90IGEgdmFsaWQgSlNPTi1SUEMgcmVzcG9uc2UsIGFuIGVycm9yIHJlc3BvbnNlLCBvciBJRCBtaXNtYXRjaC5cbiAgICovXG4gIF9wcm9jZXNzU3NlRXZlbnREYXRhKGpzb25EYXRhLCBvcmlnaW5hbFJlcXVlc3RJZCkge1xuICAgIGlmICghanNvbkRhdGEudHJpbSgpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJBdHRlbXB0ZWQgdG8gcHJvY2VzcyBlbXB0eSBTU0UgZXZlbnQgZGF0YS5cIik7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICBjb25zdCBzc2VKc29uUnBjUmVzcG9uc2UgPSBKU09OLnBhcnNlKGpzb25EYXRhLnJlcGxhY2UoL1xcbiQvLCBcIlwiKSk7XG4gICAgICBjb25zdCBhMmFTdHJlYW1SZXNwb25zZSA9IHNzZUpzb25ScGNSZXNwb25zZTtcbiAgICAgIGlmIChhMmFTdHJlYW1SZXNwb25zZS5pZCAhPT0gb3JpZ2luYWxSZXF1ZXN0SWQpIHtcbiAgICAgICAgY29uc29sZS53YXJuKGBTU0UgRXZlbnQncyBKU09OLVJQQyByZXNwb25zZSBJRCBtaXNtYXRjaC4gQ2xpZW50IHJlcXVlc3QgSUQ6ICR7b3JpZ2luYWxSZXF1ZXN0SWR9LCBldmVudCByZXNwb25zZSBJRDogJHthMmFTdHJlYW1SZXNwb25zZS5pZH0uYCk7XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5pc0Vycm9yUmVzcG9uc2UoYTJhU3RyZWFtUmVzcG9uc2UpKSB7XG4gICAgICAgIGNvbnN0IGVyciA9IGEyYVN0cmVhbVJlc3BvbnNlLmVycm9yO1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFNTRSBldmVudCBjb250YWluZWQgYW4gZXJyb3I6ICR7ZXJyLm1lc3NhZ2V9IChDb2RlOiAke2Vyci5jb2RlfSkgRGF0YTogJHtKU09OLnN0cmluZ2lmeShlcnIuZGF0YSB8fCB7fSl9YCk7XG4gICAgICB9XG4gICAgICBpZiAoIShcInJlc3VsdFwiIGluIGEyYVN0cmVhbVJlc3BvbnNlKSB8fCB0eXBlb2YgYTJhU3RyZWFtUmVzcG9uc2UucmVzdWx0ID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgU1NFIGV2ZW50IEpTT04tUlBDIHJlc3BvbnNlIGlzIG1pc3NpbmcgJ3Jlc3VsdCcgZmllbGQuIERhdGE6ICR7anNvbkRhdGF9YCk7XG4gICAgICB9XG4gICAgICBjb25zdCBzdWNjZXNzUmVzcG9uc2UgPSBhMmFTdHJlYW1SZXNwb25zZTtcbiAgICAgIHJldHVybiBzdWNjZXNzUmVzcG9uc2UucmVzdWx0O1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIGlmIChlLm1lc3NhZ2Uuc3RhcnRzV2l0aChcIlNTRSBldmVudCBjb250YWluZWQgYW4gZXJyb3JcIikgfHwgZS5tZXNzYWdlLnN0YXJ0c1dpdGgoXCJTU0UgZXZlbnQgSlNPTi1SUEMgcmVzcG9uc2UgaXMgbWlzc2luZyAncmVzdWx0JyBmaWVsZFwiKSkge1xuICAgICAgICB0aHJvdyBlO1xuICAgICAgfVxuICAgICAgY29uc29sZS5lcnJvcihcIkZhaWxlZCB0byBwYXJzZSBTU0UgZXZlbnQgZGF0YSBzdHJpbmcgb3IgdW5leHBlY3RlZCBKU09OLVJQQyBzdHJ1Y3R1cmU6XCIsIGpzb25EYXRhLCBlKTtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgRmFpbGVkIHRvIHBhcnNlIFNTRSBldmVudCBkYXRhOiBcIiR7anNvbkRhdGEuc3Vic3RyaW5nKDAsIDEwMCl9Li4uXCIuIE9yaWdpbmFsIGVycm9yOiAke2UubWVzc2FnZX1gKTtcbiAgICB9XG4gIH1cbiAgaXNFcnJvclJlc3BvbnNlKHJlc3BvbnNlKSB7XG4gICAgcmV0dXJuIFwiZXJyb3JcIiBpbiByZXNwb25zZTtcbiAgfVxuICAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuICAvLyBGdW5jdGlvbnMgdXNlZCB0byBzdXBwb3J0IG9sZCBBMkFDbGllbnQgQ29uc3RydWN0b3IgdG8gYmUgZGVwcmVjYXRlZCBzb29uXG4gIC8vIFRPRE9zOlxuICAvLyAqIHJlbW92ZSBgYWdlbnRDYXJkUHJvbWlzZWAsIGFuZCBqdXN0IHVzZSBhZ2VudENhcmQgaW5pdGlhbGl6ZWRcbiAgLy8gKiBfZ2V0U2VydmljZUVuZHBvaW50IGNhbiBiZSBtYWRlIHN5bmNocm9ub3VzIG9yIGRlbGV0ZWQgYW5kIGFjY2Vzc2VkIHZpYVxuICAvLyAgIGFnZW50Q2FyZC51cmxcbiAgLy8gKiBnZXRBZ2VudENhcmQgY2hhbmdlZCB0byB0aGlzLmFnZW50Q2FyZFxuICAvLyAqIGRlbGV0ZSByZXNvbHZlQWdlbnRDYXJkVXJsKCksIF9mZXRjaEFuZENhY2hlQWdlbnRDYXJkKCksXG4gIC8vICAgYWdlbnRDYXJkUGF0aCBmcm9tIEEyQUNsaWVudE9wdGlvbnNcbiAgLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cbiAgLyoqXG4gICAqIEZldGNoZXMgdGhlIEFnZW50IENhcmQgZnJvbSB0aGUgYWdlbnQncyB3ZWxsLWtub3duIFVSSSBhbmQgY2FjaGVzIGl0cyBzZXJ2aWNlIGVuZHBvaW50IFVSTC5cbiAgICogVGhpcyBtZXRob2QgaXMgY2FsbGVkIGJ5IHRoZSBjb25zdHJ1Y3Rvci5cbiAgICogQHBhcmFtIGFnZW50QmFzZVVybCBUaGUgYmFzZSBVUkwgb2YgdGhlIEEyQSBhZ2VudCAoZS5nLiwgaHR0cHM6Ly9hZ2VudC5leGFtcGxlLmNvbSlcbiAgICogQHBhcmFtIGFnZW50Q2FyZFBhdGggcGF0aCB0byB0aGUgYWdlbnQgY2FyZCwgZGVmYXVsdHMgdG8gLndlbGwta25vd24vYWdlbnQtY2FyZC5qc29uXG4gICAqIEByZXR1cm5zIEEgUHJvbWlzZSB0aGF0IHJlc29sdmVzIHRvIHRoZSBBZ2VudENhcmQuXG4gICAqL1xuICBhc3luYyBfZmV0Y2hBbmRDYWNoZUFnZW50Q2FyZChhZ2VudEJhc2VVcmwsIGFnZW50Q2FyZFBhdGgpIHtcbiAgICB0cnkge1xuICAgICAgY29uc3QgYWdlbnRDYXJkVXJsID0gdGhpcy5yZXNvbHZlQWdlbnRDYXJkVXJsKGFnZW50QmFzZVVybCwgYWdlbnRDYXJkUGF0aCk7XG4gICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHRoaXMuX2ZldGNoKGFnZW50Q2FyZFVybCwge1xuICAgICAgICBoZWFkZXJzOiB7IFwiQWNjZXB0XCI6IFwiYXBwbGljYXRpb24vanNvblwiIH1cbiAgICAgIH0pO1xuICAgICAgaWYgKCFyZXNwb25zZS5vaykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEZhaWxlZCB0byBmZXRjaCBBZ2VudCBDYXJkIGZyb20gJHthZ2VudENhcmRVcmx9OiAke3Jlc3BvbnNlLnN0YXR1c30gJHtyZXNwb25zZS5zdGF0dXNUZXh0fWApO1xuICAgICAgfVxuICAgICAgY29uc3QgYWdlbnRDYXJkID0gYXdhaXQgcmVzcG9uc2UuanNvbigpO1xuICAgICAgaWYgKCFhZ2VudENhcmQudXJsKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkZldGNoZWQgQWdlbnQgQ2FyZCBkb2VzIG5vdCBjb250YWluIGEgdmFsaWQgJ3VybCcgZm9yIHRoZSBzZXJ2aWNlIGVuZHBvaW50LlwiKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuc2VydmljZUVuZHBvaW50VXJsID0gYWdlbnRDYXJkLnVybDtcbiAgICAgIHJldHVybiBhZ2VudENhcmQ7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoXCJFcnJvciBmZXRjaGluZyBvciBwYXJzaW5nIEFnZW50IENhcmQ6XCIsIGVycm9yKTtcbiAgICAgIHRocm93IGVycm9yO1xuICAgIH1cbiAgfVxuICAvKipcbiAgKiBSZXRyaWV2ZXMgdGhlIEFnZW50IENhcmQuXG4gICogSWYgYW4gYGFnZW50QmFzZVVybGAgaXMgcHJvdmlkZWQsIGl0IGZldGNoZXMgdGhlIGNhcmQgZnJvbSB0aGF0IHNwZWNpZmljIFVSTC5cbiAgKiBPdGhlcndpc2UsIGl0IHJldHVybnMgdGhlIGNhcmQgZmV0Y2hlZCBhbmQgY2FjaGVkIGR1cmluZyBjbGllbnQgY29uc3RydWN0aW9uLlxuICAqIEBwYXJhbSBhZ2VudEJhc2VVcmwgT3B0aW9uYWwuIFRoZSBiYXNlIFVSTCBvZiB0aGUgYWdlbnQgdG8gZmV0Y2ggdGhlIGNhcmQgZnJvbS5cbiAgKiBAcGFyYW0gYWdlbnRDYXJkUGF0aCBwYXRoIHRvIHRoZSBhZ2VudCBjYXJkLCBkZWZhdWx0cyB0byAud2VsbC1rbm93bi9hZ2VudC1jYXJkLmpzb25cbiAgKiBJZiBwcm92aWRlZCwgdGhpcyB3aWxsIGZldGNoIGEgbmV3IGNhcmQsIG5vdCB1c2UgdGhlIGNhY2hlZCBvbmUgZnJvbSB0aGUgY29uc3RydWN0b3IncyBVUkwuXG4gICogQHJldHVybnMgQSBQcm9taXNlIHRoYXQgcmVzb2x2ZXMgdG8gdGhlIEFnZW50Q2FyZC5cbiAgKi9cbiAgYXN5bmMgZ2V0QWdlbnRDYXJkKGFnZW50QmFzZVVybCwgYWdlbnRDYXJkUGF0aCkge1xuICAgIGlmIChhZ2VudEJhc2VVcmwpIHtcbiAgICAgIGNvbnN0IGFnZW50Q2FyZFVybCA9IHRoaXMucmVzb2x2ZUFnZW50Q2FyZFVybChhZ2VudEJhc2VVcmwsIGFnZW50Q2FyZFBhdGgpO1xuICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLl9mZXRjaChhZ2VudENhcmRVcmwsIHtcbiAgICAgICAgaGVhZGVyczogeyBcIkFjY2VwdFwiOiBcImFwcGxpY2F0aW9uL2pzb25cIiB9XG4gICAgICB9KTtcbiAgICAgIGlmICghcmVzcG9uc2Uub2spIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBGYWlsZWQgdG8gZmV0Y2ggQWdlbnQgQ2FyZCBmcm9tICR7YWdlbnRDYXJkVXJsfTogJHtyZXNwb25zZS5zdGF0dXN9ICR7cmVzcG9uc2Uuc3RhdHVzVGV4dH1gKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBhd2FpdCByZXNwb25zZS5qc29uKCk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLmFnZW50Q2FyZFByb21pc2U7XG4gIH1cbiAgLyoqXG4gICAqIERldGVybWluZXMgdGhlIGFnZW50IGNhcmQgVVJMIGJhc2VkIG9uIHRoZSBhZ2VudCBVUkwuXG4gICAqIEBwYXJhbSBhZ2VudEJhc2VVcmwgVGhlIGFnZW50IFVSTC5cbiAgICogQHBhcmFtIGFnZW50Q2FyZFBhdGggT3B0aW9uYWwgcmVsYXRpdmUgcGF0aCB0byB0aGUgYWdlbnQgY2FyZCwgZGVmYXVsdHMgdG8gLndlbGwta25vd24vYWdlbnQtY2FyZC5qc29uXG4gICAqL1xuICByZXNvbHZlQWdlbnRDYXJkVXJsKGFnZW50QmFzZVVybCwgYWdlbnRDYXJkUGF0aCA9IEFHRU5UX0NBUkRfUEFUSCkge1xuICAgIHJldHVybiBgJHthZ2VudEJhc2VVcmwucmVwbGFjZSgvXFwvJC8sIFwiXCIpfS8ke2FnZW50Q2FyZFBhdGgucmVwbGFjZSgvXlxcLy8sIFwiXCIpfWA7XG4gIH1cbiAgLyoqXG4gICAqIEdldHMgdGhlIFJQQyBzZXJ2aWNlIGVuZHBvaW50IFVSTC4gRW5zdXJlcyB0aGUgYWdlbnQgY2FyZCBoYXMgYmVlbiBmZXRjaGVkIGZpcnN0LlxuICAgKiBAcmV0dXJucyBBIFByb21pc2UgdGhhdCByZXNvbHZlcyB0byB0aGUgc2VydmljZSBlbmRwb2ludCBVUkwgc3RyaW5nLlxuICAgKi9cbiAgYXN5bmMgX2dldFNlcnZpY2VFbmRwb2ludCgpIHtcbiAgICBpZiAodGhpcy5zZXJ2aWNlRW5kcG9pbnRVcmwpIHtcbiAgICAgIHJldHVybiB0aGlzLnNlcnZpY2VFbmRwb2ludFVybDtcbiAgICB9XG4gICAgYXdhaXQgdGhpcy5hZ2VudENhcmRQcm9taXNlO1xuICAgIGlmICghdGhpcy5zZXJ2aWNlRW5kcG9pbnRVcmwpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkFnZW50IENhcmQgVVJMIGZvciBSUEMgZW5kcG9pbnQgaXMgbm90IGF2YWlsYWJsZS4gRmV0Y2hpbmcgbWlnaHQgaGF2ZSBmYWlsZWQuXCIpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5zZXJ2aWNlRW5kcG9pbnRVcmw7XG4gIH1cbn07XG5cbi8vIHNyYy9jbGllbnQvYXV0aC1oYW5kbGVyLnRzXG5mdW5jdGlvbiBjcmVhdGVBdXRoZW50aWNhdGluZ0ZldGNoV2l0aFJldHJ5KGZldGNoSW1wbCwgYXV0aEhhbmRsZXIpIHtcbiAgYXN5bmMgZnVuY3Rpb24gYXV0aEZldGNoKHVybCwgaW5pdCkge1xuICAgIGNvbnN0IGF1dGhIZWFkZXJzID0gYXdhaXQgYXV0aEhhbmRsZXIuaGVhZGVycygpIHx8IHt9O1xuICAgIGNvbnN0IG1lcmdlZEluaXQgPSB7XG4gICAgICAuLi5pbml0IHx8IHt9LFxuICAgICAgaGVhZGVyczoge1xuICAgICAgICAuLi5hdXRoSGVhZGVycyxcbiAgICAgICAgLi4uaW5pdD8uaGVhZGVycyB8fCB7fVxuICAgICAgfVxuICAgIH07XG4gICAgbGV0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2hJbXBsKHVybCwgbWVyZ2VkSW5pdCk7XG4gICAgY29uc3QgdXBkYXRlZEhlYWRlcnMgPSBhd2FpdCBhdXRoSGFuZGxlci5zaG91bGRSZXRyeVdpdGhIZWFkZXJzKG1lcmdlZEluaXQsIHJlc3BvbnNlKTtcbiAgICBpZiAodXBkYXRlZEhlYWRlcnMpIHtcbiAgICAgIGNvbnN0IHJldHJ5SW5pdCA9IHtcbiAgICAgICAgLi4uaW5pdCB8fCB7fSxcbiAgICAgICAgaGVhZGVyczoge1xuICAgICAgICAgIC4uLnVwZGF0ZWRIZWFkZXJzLFxuICAgICAgICAgIC4uLmluaXQ/LmhlYWRlcnMgfHwge31cbiAgICAgICAgfVxuICAgICAgfTtcbiAgICAgIHJlc3BvbnNlID0gYXdhaXQgZmV0Y2hJbXBsKHVybCwgcmV0cnlJbml0KTtcbiAgICAgIGlmIChyZXNwb25zZS5vayAmJiBhdXRoSGFuZGxlci5vblN1Y2Nlc3NmdWxSZXRyeSkge1xuICAgICAgICBhd2FpdCBhdXRoSGFuZGxlci5vblN1Y2Nlc3NmdWxSZXRyeSh1cGRhdGVkSGVhZGVycyk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXNwb25zZTtcbiAgfVxuICBPYmplY3Quc2V0UHJvdG90eXBlT2YoYXV0aEZldGNoLCBPYmplY3QuZ2V0UHJvdG90eXBlT2YoZmV0Y2hJbXBsKSk7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKGF1dGhGZXRjaCwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMoZmV0Y2hJbXBsKSk7XG4gIHJldHVybiBhdXRoRmV0Y2g7XG59XG5leHBvcnQge1xuICBBMkFDbGllbnQsXG4gIGNyZWF0ZUF1dGhlbnRpY2F0aW5nRmV0Y2hXaXRoUmV0cnlcbn07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@a2a-js/sdk/dist/client/index.js\n");

/***/ })

};
;