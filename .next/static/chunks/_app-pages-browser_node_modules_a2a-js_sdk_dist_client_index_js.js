"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunk_N_E"] = self["webpackChunk_N_E"] || []).push([["_app-pages-browser_node_modules_a2a-js_sdk_dist_client_index_js"],{

/***/ "(app-pages-browser)/./node_modules/@a2a-js/sdk/dist/chunk-67JNQ6TZ.js":
/*!*********************************************************!*\
  !*** ./node_modules/@a2a-js/sdk/dist/chunk-67JNQ6TZ.js ***!
  \*********************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AGENT_CARD_PATH: function() { return /* binding */ AGENT_CARD_PATH; }\n/* harmony export */ });\n// src/constants.ts\nvar AGENT_CARD_PATH = \".well-known/agent-card.json\";\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AYTJhLWpzL3Nkay9kaXN0L2NodW5rLTY3Sk5RNlRaLmpzIiwibWFwcGluZ3MiOiI7Ozs7QUFBQTtBQUNBOztBQUlFIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9AYTJhLWpzL3Nkay9kaXN0L2NodW5rLTY3Sk5RNlRaLmpzPzgxODgiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gc3JjL2NvbnN0YW50cy50c1xudmFyIEFHRU5UX0NBUkRfUEFUSCA9IFwiLndlbGwta25vd24vYWdlbnQtY2FyZC5qc29uXCI7XG5cbmV4cG9ydCB7XG4gIEFHRU5UX0NBUkRfUEFUSFxufTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@a2a-js/sdk/dist/chunk-67JNQ6TZ.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@a2a-js/sdk/dist/client/index.js":
/*!*******************************************************!*\
  !*** ./node_modules/@a2a-js/sdk/dist/client/index.js ***!
  \*******************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   A2AClient: function() { return /* binding */ A2AClient; },\n/* harmony export */   createAuthenticatingFetchWithRetry: function() { return /* binding */ createAuthenticatingFetchWithRetry; }\n/* harmony export */ });\n/* harmony import */ var _chunk_67JNQ6TZ_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../chunk-67JNQ6TZ.js */ \"(app-pages-browser)/./node_modules/@a2a-js/sdk/dist/chunk-67JNQ6TZ.js\");\n\n\n// src/client/client.ts\nvar A2AClient = class _A2AClient {\n  agentCardPromise;\n  requestIdCounter = 1;\n  serviceEndpointUrl;\n  // To be populated from AgentCard after fetching\n  customFetchImpl;\n  /**\n   * Constructs an A2AClient instance from an AgentCard.\n   * @param agentCard The AgentCard object.\n   * @param options Optional. The options for the A2AClient including the fetch/auth implementation.\n   */\n  constructor(agentCard, options) {\n    this.customFetchImpl = options?.fetchImpl;\n    if (typeof agentCard === \"string\") {\n      console.warn(\"Warning: Constructing A2AClient with a URL is deprecated. Please use A2AClient.fromCardUrl() instead.\");\n      this.agentCardPromise = this._fetchAndCacheAgentCard(agentCard, options?.agentCardPath);\n    } else {\n      if (!agentCard.url) {\n        throw new Error(\"Provided Agent Card does not contain a valid 'url' for the service endpoint.\");\n      }\n      this.serviceEndpointUrl = agentCard.url;\n      this.agentCardPromise = Promise.resolve(agentCard);\n    }\n  }\n  /**\n   * Dynamically resolves the fetch implementation to use for requests. \n   * Prefers a custom implementation if provided, otherwise falls back to the global fetch.\n   * @returns The fetch implementation.\n   * @param args Arguments to pass to the fetch implementation.\n   * @throws If no fetch implementation is available.\n   */\n  _fetch(...args) {\n    if (this.customFetchImpl) {\n      return this.customFetchImpl(...args);\n    }\n    if (typeof fetch === \"function\") {\n      return fetch(...args);\n    }\n    throw new Error(\n      \"A `fetch` implementation was not provided and is not available in the global scope. Please provide a `fetchImpl` in the A2AClientOptions. For earlier Node.js versions (pre-v18), you can use a library like `node-fetch`.\"\n    );\n  }\n  /**\n   * Creates an A2AClient instance by fetching the AgentCard from a URL then constructing the A2AClient.\n   * @param agentCardUrl The URL of the agent card.\n   * @param options Optional. The options for the A2AClient including the fetch/auth implementation.\n   * @returns A Promise that resolves to a new A2AClient instance.\n   */\n  static async fromCardUrl(agentCardUrl, options) {\n    const fetchImpl = options?.fetchImpl;\n    const requestInit = {\n      headers: { \"Accept\": \"application/json\" }\n    };\n    let response;\n    if (fetchImpl) {\n      response = await fetchImpl(agentCardUrl, requestInit);\n    } else if (typeof fetch === \"function\") {\n      response = await fetch(agentCardUrl, requestInit);\n    } else {\n      throw new Error(\n        \"A `fetch` implementation was not provided and is not available in the global scope. Please provide a `fetchImpl` in the A2AClientOptions. For earlier Node.js versions (pre-v18), you can use a library like `node-fetch`.\"\n      );\n    }\n    if (!response.ok) {\n      throw new Error(`Failed to fetch Agent Card from ${agentCardUrl}: ${response.status} ${response.statusText}`);\n    }\n    let agentCard;\n    try {\n      agentCard = await response.json();\n    } catch (error) {\n      console.error(\"Failed to parse Agent Card JSON:\", error);\n      throw new Error(`Failed to parse Agent Card JSON from ${agentCardUrl}. Original error: ${error.message}`);\n    }\n    return new _A2AClient(agentCard, options);\n  }\n  /**\n   * Helper method to make a generic JSON-RPC POST request.\n   * @param method The RPC method name.\n   * @param params The parameters for the RPC method.\n   * @returns A Promise that resolves to the RPC response.\n   */\n  async _postRpcRequest(method, params) {\n    const endpoint = await this._getServiceEndpoint();\n    const requestId = this.requestIdCounter++;\n    const rpcRequest = {\n      jsonrpc: \"2.0\",\n      method,\n      params,\n      // Cast because TParams structure varies per method\n      id: requestId\n    };\n    const httpResponse = await this._fetchRpc(endpoint, rpcRequest);\n    if (!httpResponse.ok) {\n      let errorBodyText = \"(empty or non-JSON response)\";\n      try {\n        errorBodyText = await httpResponse.text();\n        const errorJson = JSON.parse(errorBodyText);\n        if (errorJson.jsonrpc && errorJson.error) {\n          return errorJson;\n        } else if (!errorJson.jsonrpc && errorJson.error) {\n          throw new Error(`RPC error for ${method}: ${errorJson.error.message} (Code: ${errorJson.error.code}, HTTP Status: ${httpResponse.status}) Data: ${JSON.stringify(errorJson.error.data || {})}`);\n        } else if (!errorJson.jsonrpc) {\n          throw new Error(`HTTP error for ${method}! Status: ${httpResponse.status} ${httpResponse.statusText}. Response: ${errorBodyText}`);\n        }\n      } catch (e) {\n        if (e.message.startsWith(\"RPC error for\") || e.message.startsWith(\"HTTP error for\")) throw e;\n        throw new Error(`HTTP error for ${method}! Status: ${httpResponse.status} ${httpResponse.statusText}. Response: ${errorBodyText}`);\n      }\n    }\n    const rpcResponse = await httpResponse.json();\n    if (rpcResponse.id !== requestId) {\n      console.error(`CRITICAL: RPC response ID mismatch for method ${method}. Expected ${requestId}, got ${rpcResponse.id}. This may lead to incorrect response handling.`);\n    }\n    return rpcResponse;\n  }\n  /**\n   * Internal helper method to fetch the RPC service endpoint.\n   * @param url The URL to fetch.\n   * @param rpcRequest The JSON-RPC request to send.\n   * @param acceptHeader The Accept header to use.  Defaults to \"application/json\".\n   * @returns A Promise that resolves to the fetch HTTP response.\n   */\n  async _fetchRpc(url, rpcRequest, acceptHeader = \"application/json\") {\n    const requestInit = {\n      method: \"POST\",\n      headers: {\n        \"Content-Type\": \"application/json\",\n        \"Accept\": acceptHeader\n        // Expect JSON response for non-streaming requests\n      },\n      body: JSON.stringify(rpcRequest)\n    };\n    return this._fetch(url, requestInit);\n  }\n  /**\n   * Sends a message to the agent.\n   * The behavior (blocking/non-blocking) and push notification configuration\n   * are specified within the `params.configuration` object.\n   * Optionally, `params.message.contextId` or `params.message.taskId` can be provided.\n   * @param params The parameters for sending the message, including the message content and configuration.\n   * @returns A Promise resolving to SendMessageResponse, which can be a Message, Task, or an error.\n   */\n  async sendMessage(params) {\n    return this._postRpcRequest(\"message/send\", params);\n  }\n  /**\n   * Sends a message to the agent and streams back responses using Server-Sent Events (SSE).\n   * Push notification configuration can be specified in `params.configuration`.\n   * Optionally, `params.message.contextId` or `params.message.taskId` can be provided.\n   * Requires the agent to support streaming (`capabilities.streaming: true` in AgentCard).\n   * @param params The parameters for sending the message.\n   * @returns An AsyncGenerator yielding A2AStreamEventData (Message, Task, TaskStatusUpdateEvent, or TaskArtifactUpdateEvent).\n   * The generator throws an error if streaming is not supported or if an HTTP/SSE error occurs.\n   */\n  async *sendMessageStream(params) {\n    const agentCard = await this.agentCardPromise;\n    if (!agentCard.capabilities?.streaming) {\n      throw new Error(\"Agent does not support streaming (AgentCard.capabilities.streaming is not true).\");\n    }\n    const endpoint = await this._getServiceEndpoint();\n    const clientRequestId = this.requestIdCounter++;\n    const rpcRequest = {\n      // This is the initial JSON-RPC request to establish the stream\n      jsonrpc: \"2.0\",\n      method: \"message/stream\",\n      params,\n      id: clientRequestId\n    };\n    const response = await this._fetchRpc(endpoint, rpcRequest, \"text/event-stream\");\n    if (!response.ok) {\n      let errorBody = \"\";\n      try {\n        errorBody = await response.text();\n        const errorJson = JSON.parse(errorBody);\n        if (errorJson.error) {\n          throw new Error(`HTTP error establishing stream for message/stream: ${response.status} ${response.statusText}. RPC Error: ${errorJson.error.message} (Code: ${errorJson.error.code})`);\n        }\n      } catch (e) {\n        if (e.message.startsWith(\"HTTP error establishing stream\")) throw e;\n        throw new Error(`HTTP error establishing stream for message/stream: ${response.status} ${response.statusText}. Response: ${errorBody || \"(empty)\"}`);\n      }\n      throw new Error(`HTTP error establishing stream for message/stream: ${response.status} ${response.statusText}`);\n    }\n    if (!response.headers.get(\"Content-Type\")?.startsWith(\"text/event-stream\")) {\n      throw new Error(\"Invalid response Content-Type for SSE stream. Expected 'text/event-stream'.\");\n    }\n    yield* this._parseA2ASseStream(response, clientRequestId);\n  }\n  /**\n   * Sets or updates the push notification configuration for a given task.\n   * Requires the agent to support push notifications (`capabilities.pushNotifications: true` in AgentCard).\n   * @param params Parameters containing the taskId and the TaskPushNotificationConfig.\n   * @returns A Promise resolving to SetTaskPushNotificationConfigResponse.\n   */\n  async setTaskPushNotificationConfig(params) {\n    const agentCard = await this.agentCardPromise;\n    if (!agentCard.capabilities?.pushNotifications) {\n      throw new Error(\"Agent does not support push notifications (AgentCard.capabilities.pushNotifications is not true).\");\n    }\n    return this._postRpcRequest(\n      \"tasks/pushNotificationConfig/set\",\n      params\n    );\n  }\n  /**\n   * Gets the push notification configuration for a given task.\n   * @param params Parameters containing the taskId.\n   * @returns A Promise resolving to GetTaskPushNotificationConfigResponse.\n   */\n  async getTaskPushNotificationConfig(params) {\n    return this._postRpcRequest(\n      \"tasks/pushNotificationConfig/get\",\n      params\n    );\n  }\n  /**\n   * Lists the push notification configurations for a given task.\n   * @param params Parameters containing the taskId.\n   * @returns A Promise resolving to ListTaskPushNotificationConfigResponse.\n   */\n  async listTaskPushNotificationConfig(params) {\n    return this._postRpcRequest(\n      \"tasks/pushNotificationConfig/list\",\n      params\n    );\n  }\n  /**\n   * Deletes the push notification configuration for a given task.\n   * @param params Parameters containing the taskId and push notification configuration ID.\n   * @returns A Promise resolving to DeleteTaskPushNotificationConfigResponse.\n   */\n  async deleteTaskPushNotificationConfig(params) {\n    return this._postRpcRequest(\n      \"tasks/pushNotificationConfig/delete\",\n      params\n    );\n  }\n  /**\n   * Retrieves a task by its ID.\n   * @param params Parameters containing the taskId and optional historyLength.\n   * @returns A Promise resolving to GetTaskResponse, which contains the Task object or an error.\n   */\n  async getTask(params) {\n    return this._postRpcRequest(\"tasks/get\", params);\n  }\n  /**\n   * Cancels a task by its ID.\n   * @param params Parameters containing the taskId.\n   * @returns A Promise resolving to CancelTaskResponse, which contains the updated Task object or an error.\n   */\n  async cancelTask(params) {\n    return this._postRpcRequest(\"tasks/cancel\", params);\n  }\n  /**\n   * @template TExtensionParams The type of parameters for the custom extension method.\n   * @template TExtensionResponse The type of response expected from the custom extension method. \n   * This should extend JSONRPCResponse. This ensures the extension response is still a valid A2A response.\n   * @param method Custom JSON-RPC method defined in the AgentCard's extensions.\n   * @param params Extension paramters defined in the AgentCard's extensions.\n   * @returns A Promise that resolves to the RPC response.\n   */\n  async callExtensionMethod(method, params) {\n    return this._postRpcRequest(method, params);\n  }\n  /**\n   * Resubscribes to a task's event stream using Server-Sent Events (SSE).\n   * This is used if a previous SSE connection for an active task was broken.\n   * Requires the agent to support streaming (`capabilities.streaming: true` in AgentCard).\n   * @param params Parameters containing the taskId.\n   * @returns An AsyncGenerator yielding A2AStreamEventData (Message, Task, TaskStatusUpdateEvent, or TaskArtifactUpdateEvent).\n   */\n  async *resubscribeTask(params) {\n    const agentCard = await this.agentCardPromise;\n    if (!agentCard.capabilities?.streaming) {\n      throw new Error(\"Agent does not support streaming (required for tasks/resubscribe).\");\n    }\n    const endpoint = await this._getServiceEndpoint();\n    const clientRequestId = this.requestIdCounter++;\n    const rpcRequest = {\n      // Initial JSON-RPC request to establish the stream\n      jsonrpc: \"2.0\",\n      method: \"tasks/resubscribe\",\n      params,\n      id: clientRequestId\n    };\n    const response = await this._fetch(endpoint, {\n      method: \"POST\",\n      headers: {\n        \"Content-Type\": \"application/json\",\n        \"Accept\": \"text/event-stream\"\n      },\n      body: JSON.stringify(rpcRequest)\n    });\n    if (!response.ok) {\n      let errorBody = \"\";\n      try {\n        errorBody = await response.text();\n        const errorJson = JSON.parse(errorBody);\n        if (errorJson.error) {\n          throw new Error(`HTTP error establishing stream for tasks/resubscribe: ${response.status} ${response.statusText}. RPC Error: ${errorJson.error.message} (Code: ${errorJson.error.code})`);\n        }\n      } catch (e) {\n        if (e.message.startsWith(\"HTTP error establishing stream\")) throw e;\n        throw new Error(`HTTP error establishing stream for tasks/resubscribe: ${response.status} ${response.statusText}. Response: ${errorBody || \"(empty)\"}`);\n      }\n      throw new Error(`HTTP error establishing stream for tasks/resubscribe: ${response.status} ${response.statusText}`);\n    }\n    if (!response.headers.get(\"Content-Type\")?.startsWith(\"text/event-stream\")) {\n      throw new Error(\"Invalid response Content-Type for SSE stream on resubscribe. Expected 'text/event-stream'.\");\n    }\n    yield* this._parseA2ASseStream(response, clientRequestId);\n  }\n  /**\n   * Parses an HTTP response body as an A2A Server-Sent Event stream.\n   * Each 'data' field of an SSE event is expected to be a JSON-RPC 2.0 Response object,\n   * specifically a SendStreamingMessageResponse (or similar structure for resubscribe).\n   * @param response The HTTP Response object whose body is the SSE stream.\n   * @param originalRequestId The ID of the client's JSON-RPC request that initiated this stream.\n   * Used to validate the `id` in the streamed JSON-RPC responses.\n   * @returns An AsyncGenerator yielding the `result` field of each valid JSON-RPC success response from the stream.\n   */\n  async *_parseA2ASseStream(response, originalRequestId) {\n    if (!response.body) {\n      throw new Error(\"SSE response body is undefined. Cannot read stream.\");\n    }\n    const reader = response.body.pipeThrough(new TextDecoderStream()).getReader();\n    let buffer = \"\";\n    let eventDataBuffer = \"\";\n    try {\n      while (true) {\n        const { done, value } = await reader.read();\n        if (done) {\n          if (eventDataBuffer.trim()) {\n            const result = this._processSseEventData(eventDataBuffer, originalRequestId);\n            yield result;\n          }\n          break;\n        }\n        buffer += value;\n        let lineEndIndex;\n        while ((lineEndIndex = buffer.indexOf(\"\\n\")) >= 0) {\n          const line = buffer.substring(0, lineEndIndex).trim();\n          buffer = buffer.substring(lineEndIndex + 1);\n          if (line === \"\") {\n            if (eventDataBuffer) {\n              const result = this._processSseEventData(eventDataBuffer, originalRequestId);\n              yield result;\n              eventDataBuffer = \"\";\n            }\n          } else if (line.startsWith(\"data:\")) {\n            eventDataBuffer += line.substring(5).trimStart() + \"\\n\";\n          } else if (line.startsWith(\":\")) {\n          } else if (line.includes(\":\")) {\n          }\n        }\n      }\n    } catch (error) {\n      console.error(\"Error reading or parsing SSE stream:\", error.message);\n      throw error;\n    } finally {\n      reader.releaseLock();\n    }\n  }\n  /**\n   * Processes a single SSE event's data string, expecting it to be a JSON-RPC response.\n   * @param jsonData The string content from one or more 'data:' lines of an SSE event.\n   * @param originalRequestId The ID of the client's request that initiated the stream.\n   * @returns The `result` field of the parsed JSON-RPC success response.\n   * @throws Error if data is not valid JSON, not a valid JSON-RPC response, an error response, or ID mismatch.\n   */\n  _processSseEventData(jsonData, originalRequestId) {\n    if (!jsonData.trim()) {\n      throw new Error(\"Attempted to process empty SSE event data.\");\n    }\n    try {\n      const sseJsonRpcResponse = JSON.parse(jsonData.replace(/\\n$/, \"\"));\n      const a2aStreamResponse = sseJsonRpcResponse;\n      if (a2aStreamResponse.id !== originalRequestId) {\n        console.warn(`SSE Event's JSON-RPC response ID mismatch. Client request ID: ${originalRequestId}, event response ID: ${a2aStreamResponse.id}.`);\n      }\n      if (this.isErrorResponse(a2aStreamResponse)) {\n        const err = a2aStreamResponse.error;\n        throw new Error(`SSE event contained an error: ${err.message} (Code: ${err.code}) Data: ${JSON.stringify(err.data || {})}`);\n      }\n      if (!(\"result\" in a2aStreamResponse) || typeof a2aStreamResponse.result === \"undefined\") {\n        throw new Error(`SSE event JSON-RPC response is missing 'result' field. Data: ${jsonData}`);\n      }\n      const successResponse = a2aStreamResponse;\n      return successResponse.result;\n    } catch (e) {\n      if (e.message.startsWith(\"SSE event contained an error\") || e.message.startsWith(\"SSE event JSON-RPC response is missing 'result' field\")) {\n        throw e;\n      }\n      console.error(\"Failed to parse SSE event data string or unexpected JSON-RPC structure:\", jsonData, e);\n      throw new Error(`Failed to parse SSE event data: \"${jsonData.substring(0, 100)}...\". Original error: ${e.message}`);\n    }\n  }\n  isErrorResponse(response) {\n    return \"error\" in response;\n  }\n  ////////////////////////////////////////////////////////////////////////////////\n  // Functions used to support old A2AClient Constructor to be deprecated soon\n  // TODOs:\n  // * remove `agentCardPromise`, and just use agentCard initialized\n  // * _getServiceEndpoint can be made synchronous or deleted and accessed via\n  //   agentCard.url\n  // * getAgentCard changed to this.agentCard\n  // * delete resolveAgentCardUrl(), _fetchAndCacheAgentCard(),\n  //   agentCardPath from A2AClientOptions\n  ////////////////////////////////////////////////////////////////////////////////\n  /**\n   * Fetches the Agent Card from the agent's well-known URI and caches its service endpoint URL.\n   * This method is called by the constructor.\n   * @param agentBaseUrl The base URL of the A2A agent (e.g., https://agent.example.com)\n   * @param agentCardPath path to the agent card, defaults to .well-known/agent-card.json\n   * @returns A Promise that resolves to the AgentCard.\n   */\n  async _fetchAndCacheAgentCard(agentBaseUrl, agentCardPath) {\n    try {\n      const agentCardUrl = this.resolveAgentCardUrl(agentBaseUrl, agentCardPath);\n      const response = await this._fetch(agentCardUrl, {\n        headers: { \"Accept\": \"application/json\" }\n      });\n      if (!response.ok) {\n        throw new Error(`Failed to fetch Agent Card from ${agentCardUrl}: ${response.status} ${response.statusText}`);\n      }\n      const agentCard = await response.json();\n      if (!agentCard.url) {\n        throw new Error(\"Fetched Agent Card does not contain a valid 'url' for the service endpoint.\");\n      }\n      this.serviceEndpointUrl = agentCard.url;\n      return agentCard;\n    } catch (error) {\n      console.error(\"Error fetching or parsing Agent Card:\", error);\n      throw error;\n    }\n  }\n  /**\n  * Retrieves the Agent Card.\n  * If an `agentBaseUrl` is provided, it fetches the card from that specific URL.\n  * Otherwise, it returns the card fetched and cached during client construction.\n  * @param agentBaseUrl Optional. The base URL of the agent to fetch the card from.\n  * @param agentCardPath path to the agent card, defaults to .well-known/agent-card.json\n  * If provided, this will fetch a new card, not use the cached one from the constructor's URL.\n  * @returns A Promise that resolves to the AgentCard.\n  */\n  async getAgentCard(agentBaseUrl, agentCardPath) {\n    if (agentBaseUrl) {\n      const agentCardUrl = this.resolveAgentCardUrl(agentBaseUrl, agentCardPath);\n      const response = await this._fetch(agentCardUrl, {\n        headers: { \"Accept\": \"application/json\" }\n      });\n      if (!response.ok) {\n        throw new Error(`Failed to fetch Agent Card from ${agentCardUrl}: ${response.status} ${response.statusText}`);\n      }\n      return await response.json();\n    }\n    return this.agentCardPromise;\n  }\n  /**\n   * Determines the agent card URL based on the agent URL.\n   * @param agentBaseUrl The agent URL.\n   * @param agentCardPath Optional relative path to the agent card, defaults to .well-known/agent-card.json\n   */\n  resolveAgentCardUrl(agentBaseUrl, agentCardPath = _chunk_67JNQ6TZ_js__WEBPACK_IMPORTED_MODULE_0__.AGENT_CARD_PATH) {\n    return `${agentBaseUrl.replace(/\\/$/, \"\")}/${agentCardPath.replace(/^\\//, \"\")}`;\n  }\n  /**\n   * Gets the RPC service endpoint URL. Ensures the agent card has been fetched first.\n   * @returns A Promise that resolves to the service endpoint URL string.\n   */\n  async _getServiceEndpoint() {\n    if (this.serviceEndpointUrl) {\n      return this.serviceEndpointUrl;\n    }\n    await this.agentCardPromise;\n    if (!this.serviceEndpointUrl) {\n      throw new Error(\"Agent Card URL for RPC endpoint is not available. Fetching might have failed.\");\n    }\n    return this.serviceEndpointUrl;\n  }\n};\n\n// src/client/auth-handler.ts\nfunction createAuthenticatingFetchWithRetry(fetchImpl, authHandler) {\n  async function authFetch(url, init) {\n    const authHeaders = await authHandler.headers() || {};\n    const mergedInit = {\n      ...init || {},\n      headers: {\n        ...authHeaders,\n        ...init?.headers || {}\n      }\n    };\n    let response = await fetchImpl(url, mergedInit);\n    const updatedHeaders = await authHandler.shouldRetryWithHeaders(mergedInit, response);\n    if (updatedHeaders) {\n      const retryInit = {\n        ...init || {},\n        headers: {\n          ...updatedHeaders,\n          ...init?.headers || {}\n        }\n      };\n      response = await fetchImpl(url, retryInit);\n      if (response.ok && authHandler.onSuccessfulRetry) {\n        await authHandler.onSuccessfulRetry(updatedHeaders);\n      }\n    }\n    return response;\n  }\n  Object.setPrototypeOf(authFetch, Object.getPrototypeOf(fetchImpl));\n  Object.defineProperties(authFetch, Object.getOwnPropertyDescriptors(fetchImpl));\n  return authFetch;\n}\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AYTJhLWpzL3Nkay9kaXN0L2NsaWVudC9pbmRleC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7QUFFOEI7O0FBRTlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlEQUF5RCxhQUFhLElBQUksaUJBQWlCLEVBQUUsb0JBQW9CO0FBQ2pIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsOERBQThELGFBQWEsb0JBQW9CLGNBQWM7QUFDN0c7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWLDJDQUEyQyxPQUFPLElBQUkseUJBQXlCLFNBQVMscUJBQXFCLGlCQUFpQixvQkFBb0IsVUFBVSx5Q0FBeUMsRUFBRTtBQUN2TSxVQUFVO0FBQ1YsNENBQTRDLE9BQU8sWUFBWSxxQkFBcUIsRUFBRSx3QkFBd0IsY0FBYyxjQUFjO0FBQzFJO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsMENBQTBDLE9BQU8sWUFBWSxxQkFBcUIs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ZGVfbW9kdWxlcy9AYTJhLWpzL3Nkay9kaXN0L2NsaWVudC9pbmRleC5qcz84NDk2Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7XG4gIEFHRU5UX0NBUkRfUEFUSFxufSBmcm9tIFwiLi4vY2h1bmstNjdKTlE2VFouanNcIjtcblxuLy8gc3JjL2NsaWVudC9jbGllbnQudHNcbnZhciBBMkFDbGllbnQgPSBjbGFzcyBfQTJBQ2xpZW50IHtcbiAgYWdlbnRDYXJkUHJvbWlzZTtcbiAgcmVxdWVzdElkQ291bnRlciA9IDE7XG4gIHNlcnZpY2VFbmRwb2ludFVybDtcbiAgLy8gVG8gYmUgcG9wdWxhdGVkIGZyb20gQWdlbnRDYXJkIGFmdGVyIGZldGNoaW5nXG4gIGN1c3RvbUZldGNoSW1wbDtcbiAgLyoqXG4gICAqIENvbnN0cnVjdHMgYW4gQTJBQ2xpZW50IGluc3RhbmNlIGZyb20gYW4gQWdlbnRDYXJkLlxuICAgKiBAcGFyYW0gYWdlbnRDYXJkIFRoZSBBZ2VudENhcmQgb2JqZWN0LlxuICAgKiBAcGFyYW0gb3B0aW9ucyBPcHRpb25hbC4gVGhlIG9wdGlvbnMgZm9yIHRoZSBBMkFDbGllbnQgaW5jbHVkaW5nIHRoZSBmZXRjaC9hdXRoIGltcGxlbWVudGF0aW9uLlxuICAgKi9cbiAgY29uc3RydWN0b3IoYWdlbnRDYXJkLCBvcHRpb25zKSB7XG4gICAgdGhpcy5jdXN0b21GZXRjaEltcGwgPSBvcHRpb25zPy5mZXRjaEltcGw7XG4gICAgaWYgKHR5cGVvZiBhZ2VudENhcmQgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgIGNvbnNvbGUud2FybihcIldhcm5pbmc6IENvbnN0cnVjdGluZyBBMkFDbGllbnQgd2l0aCBhIFVSTCBpcyBkZXByZWNhdGVkLiBQbGVhc2UgdXNlIEEyQUNsaWVudC5mcm9tQ2FyZFVybCgpIGluc3RlYWQuXCIpO1xuICAgICAgdGhpcy5hZ2VudENhcmRQcm9taXNlID0gdGhpcy5fZmV0Y2hBbmRDYWNoZUFnZW50Q2FyZChhZ2VudENhcmQsIG9wdGlvbnM/LmFnZW50Q2FyZFBhdGgpO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoIWFnZW50Q2FyZC51cmwpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiUHJvdmlkZWQgQWdlbnQgQ2FyZCBkb2VzIG5vdCBjb250YWluIGEgdmFsaWQgJ3VybCcgZm9yIHRoZSBzZXJ2aWNlIGVuZHBvaW50LlwiKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuc2VydmljZUVuZHBvaW50VXJsID0gYWdlbnRDYXJkLnVybDtcbiAgICAgIHRoaXMuYWdlbnRDYXJkUHJvbWlzZSA9IFByb21pc2UucmVzb2x2ZShhZ2VudENhcmQpO1xuICAgIH1cbiAgfVxuICAvKipcbiAgICogRHluYW1pY2FsbHkgcmVzb2x2ZXMgdGhlIGZldGNoIGltcGxlbWVudGF0aW9uIHRvIHVzZSBmb3IgcmVxdWVzdHMuIFxuICAgKiBQcmVmZXJzIGEgY3VzdG9tIGltcGxlbWVudGF0aW9uIGlmIHByb3ZpZGVkLCBvdGhlcndpc2UgZmFsbHMgYmFjayB0byB0aGUgZ2xvYmFsIGZldGNoLlxuICAgKiBAcmV0dXJucyBUaGUgZmV0Y2ggaW1wbGVtZW50YXRpb24uXG4gICAqIEBwYXJhbSBhcmdzIEFyZ3VtZW50cyB0byBwYXNzIHRvIHRoZSBmZXRjaCBpbXBsZW1lbnRhdGlvbi5cbiAgICogQHRocm93cyBJZiBubyBmZXRjaCBpbXBsZW1lbnRhdGlvbiBpcyBhdmFpbGFibGUuXG4gICAqL1xuICBfZmV0Y2goLi4uYXJncykge1xuICAgIGlmICh0aGlzLmN1c3RvbUZldGNoSW1wbCkge1xuICAgICAgcmV0dXJuIHRoaXMuY3VzdG9tRmV0Y2hJbXBsKC4uLmFyZ3MpO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIGZldGNoID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgIHJldHVybiBmZXRjaCguLi5hcmdzKTtcbiAgICB9XG4gICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgXCJBIGBmZXRjaGAgaW1wbGVtZW50YXRpb24gd2FzIG5vdCBwcm92aWRlZCBhbmQgaXMgbm90IGF2YWlsYWJsZSBpbiB0aGUgZ2xvYmFsIHNjb3BlLiBQbGVhc2UgcHJvdmlkZSBhIGBmZXRjaEltcGxgIGluIHRoZSBBMkFDbGllbnRPcHRpb25zLiBGb3IgZWFybGllciBOb2RlLmpzIHZlcnNpb25zIChwcmUtdjE4KSwgeW91IGNhbiB1c2UgYSBsaWJyYXJ5IGxpa2UgYG5vZGUtZmV0Y2hgLlwiXG4gICAgKTtcbiAgfVxuICAvKipcbiAgICogQ3JlYXRlcyBhbiBBMkFDbGllbnQgaW5zdGFuY2UgYnkgZmV0Y2hpbmcgdGhlIEFnZW50Q2FyZCBmcm9tIGEgVVJMIHRoZW4gY29uc3RydWN0aW5nIHRoZSBBMkFDbGllbnQuXG4gICAqIEBwYXJhbSBhZ2VudENhcmRVcmwgVGhlIFVSTCBvZiB0aGUgYWdlbnQgY2FyZC5cbiAgICogQHBhcmFtIG9wdGlvbnMgT3B0aW9uYWwuIFRoZSBvcHRpb25zIGZvciB0aGUgQTJBQ2xpZW50IGluY2x1ZGluZyB0aGUgZmV0Y2gvYXV0aCBpbXBsZW1lbnRhdGlvbi5cbiAgICogQHJldHVybnMgQSBQcm9taXNlIHRoYXQgcmVzb2x2ZXMgdG8gYSBuZXcgQTJBQ2xpZW50IGluc3RhbmNlLlxuICAgKi9cbiAgc3RhdGljIGFzeW5jIGZyb21DYXJkVXJsKGFnZW50Q2FyZFVybCwgb3B0aW9ucykge1xuICAgIGNvbnN0IGZldGNoSW1wbCA9IG9wdGlvbnM/LmZldGNoSW1wbDtcbiAgICBjb25zdCByZXF1ZXN0SW5pdCA9IHtcbiAgICAgIGhlYWRlcnM6IHsgXCJBY2NlcHRcIjogXCJhcHBsaWNhdGlvbi9qc29uXCIgfVxuICAgIH07XG4gICAgbGV0IHJlc3BvbnNlO1xuICAgIGlmIChmZXRjaEltcGwpIHtcbiAgICAgIHJlc3BvbnNlID0gYXdhaXQgZmV0Y2hJbXBsKGFnZW50Q2FyZFVybCwgcmVxdWVzdEluaXQpO1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIGZldGNoID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgIHJlc3BvbnNlID0gYXdhaXQgZmV0Y2goYWdlbnRDYXJkVXJsLCByZXF1ZXN0SW5pdCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgXCJBIGBmZXRjaGAgaW1wbGVtZW50YXRpb24gd2FzIG5vdCBwcm92aWRlZCBhbmQgaXMgbm90IGF2YWlsYWJsZSBpbiB0aGUgZ2xvYmFsIHNjb3BlLiBQbGVhc2UgcHJvdmlkZSBhIGBmZXRjaEltcGxgIGluIHRoZSBBMkFDbGllbnRPcHRpb25zLiBGb3IgZWFybGllciBOb2RlLmpzIHZlcnNpb25zIChwcmUtdjE4KSwgeW91IGNhbiB1c2UgYSBsaWJyYXJ5IGxpa2UgYG5vZGUtZmV0Y2hgLlwiXG4gICAgICApO1xuICAgIH1cbiAgICBpZiAoIXJlc3BvbnNlLm9rKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYEZhaWxlZCB0byBmZXRjaCBBZ2VudCBDYXJkIGZyb20gJHthZ2VudENhcmRVcmx9OiAke3Jlc3BvbnNlLnN0YXR1c30gJHtyZXNwb25zZS5zdGF0dXNUZXh0fWApO1xuICAgIH1cbiAgICBsZXQgYWdlbnRDYXJkO1xuICAgIHRyeSB7XG4gICAgICBhZ2VudENhcmQgPSBhd2FpdCByZXNwb25zZS5qc29uKCk7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoXCJGYWlsZWQgdG8gcGFyc2UgQWdlbnQgQ2FyZCBKU09OOlwiLCBlcnJvcik7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYEZhaWxlZCB0byBwYXJzZSBBZ2VudCBDYXJkIEpTT04gZnJvbSAke2FnZW50Q2FyZFVybH0uIE9yaWdpbmFsIGVycm9yOiAke2Vycm9yLm1lc3NhZ2V9YCk7XG4gICAgfVxuICAgIHJldHVybiBuZXcgX0EyQUNsaWVudChhZ2VudENhcmQsIG9wdGlvbnMpO1xuICB9XG4gIC8qKlxuICAgKiBIZWxwZXIgbWV0aG9kIHRvIG1ha2UgYSBnZW5lcmljIEpTT04tUlBDIFBPU1QgcmVxdWVzdC5cbiAgICogQHBhcmFtIG1ldGhvZCBUaGUgUlBDIG1ldGhvZCBuYW1lLlxuICAgKiBAcGFyYW0gcGFyYW1zIFRoZSBwYXJhbWV0ZXJzIGZvciB0aGUgUlBDIG1ldGhvZC5cbiAgICogQHJldHVybnMgQSBQcm9taXNlIHRoYXQgcmVzb2x2ZXMgdG8gdGhlIFJQQyByZXNwb25zZS5cbiAgICovXG4gIGFzeW5jIF9wb3N0UnBjUmVxdWVzdChtZXRob2QsIHBhcmFtcykge1xuICAgIGNvbnN0IGVuZHBvaW50ID0gYXdhaXQgdGhpcy5fZ2V0U2VydmljZUVuZHBvaW50KCk7XG4gICAgY29uc3QgcmVxdWVzdElkID0gdGhpcy5yZXF1ZXN0SWRDb3VudGVyKys7XG4gICAgY29uc3QgcnBjUmVxdWVzdCA9IHtcbiAgICAgIGpzb25ycGM6IFwiMi4wXCIsXG4gICAgICBtZXRob2QsXG4gICAgICBwYXJhbXMsXG4gICAgICAvLyBDYXN0IGJlY2F1c2UgVFBhcmFtcyBzdHJ1Y3R1cmUgdmFyaWVzIHBlciBtZXRob2RcbiAgICAgIGlkOiByZXF1ZXN0SWRcbiAgICB9O1xuICAgIGNvbnN0IGh0dHBSZXNwb25zZSA9IGF3YWl0IHRoaXMuX2ZldGNoUnBjKGVuZHBvaW50LCBycGNSZXF1ZXN0KTtcbiAgICBpZiAoIWh0dHBSZXNwb25zZS5vaykge1xuICAgICAgbGV0IGVycm9yQm9keVRleHQgPSBcIihlbXB0eSBvciBub24tSlNPTiByZXNwb25zZSlcIjtcbiAgICAgIHRyeSB7XG4gICAgICAgIGVycm9yQm9keVRleHQgPSBhd2FpdCBodHRwUmVzcG9uc2UudGV4dCgpO1xuICAgICAgICBjb25zdCBlcnJvckpzb24gPSBKU09OLnBhcnNlKGVycm9yQm9keVRleHQpO1xuICAgICAgICBpZiAoZXJyb3JKc29uLmpzb25ycGMgJiYgZXJyb3JKc29uLmVycm9yKSB7XG4gICAgICAgICAgcmV0dXJuIGVycm9ySnNvbjtcbiAgICAgICAgfSBlbHNlIGlmICghZXJyb3JKc29uLmpzb25ycGMgJiYgZXJyb3JKc29uLmVycm9yKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBSUEMgZXJyb3IgZm9yICR7bWV0aG9kfTogJHtlcnJvckpzb24uZXJyb3IubWVzc2FnZX0gKENvZGU6ICR7ZXJyb3JKc29uLmVycm9yLmNvZGV9LCBIVFRQIFN0YXR1czogJHtodHRwUmVzcG9uc2Uuc3RhdHVzfSkgRGF0YTogJHtKU09OLnN0cmluZ2lmeShlcnJvckpzb24uZXJyb3IuZGF0YSB8fCB7fSl9YCk7XG4gICAgICAgIH0gZWxzZSBpZiAoIWVycm9ySnNvbi5qc29ucnBjKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBIVFRQIGVycm9yIGZvciAke21ldGhvZH0hIFN0YXR1czogJHtodHRwUmVzcG9uc2Uuc3RhdHVzfSAke2h0dHBSZXNwb25zZS5zdGF0dXNUZXh0fS4gUmVzcG9uc2U6ICR7ZXJyb3JCb2R5VGV4dH1gKTtcbiAgICAgICAgfVxuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBpZiAoZS5tZXNzYWdlLnN0YXJ0c1dpdGgoXCJSUEMgZXJyb3IgZm9yXCIpIHx8IGUubWVzc2FnZS5zdGFydHNXaXRoKFwiSFRUUCBlcnJvciBmb3JcIikpIHRocm93IGU7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgSFRUUCBlcnJvciBmb3IgJHttZXRob2R9ISBTdGF0dXM6ICR7aHR0cFJlc3BvbnNlLnN0YXR1c30gJHtodHRwUmVzcG9uc2Uuc3RhdHVzVGV4dH0uIFJlc3BvbnNlOiAke2Vycm9yQm9keVRleHR9YCk7XG4gICAgICB9XG4gICAgfVxuICAgIGNvbnN0IHJwY1Jlc3BvbnNlID0gYXdhaXQgaHR0cFJlc3BvbnNlLmpzb24oKTtcbiAgICBpZiAocnBjUmVzcG9uc2UuaWQgIT09IHJlcXVlc3RJZCkge1xuICAgICAgY29uc29sZS5lcnJvcihgQ1JJVElDQUw6IFJQQyByZXNwb25zZSBJRCBtaXNtYXRjaCBmb3IgbWV0aG9kICR7bWV0aG9kfS4gRXhwZWN0ZWQgJHtyZXF1ZXN0SWR9LCBnb3QgJHtycGNSZXNwb25zZS5pZH0uIFRoaXMgbWF5IGxlYWQgdG8gaW5jb3JyZWN0IHJlc3BvbnNlIGhhbmRsaW5nLmApO1xuICAgIH1cbiAgICByZXR1cm4gcnBjUmVzcG9uc2U7XG4gIH1cbiAgLyoqXG4gICAqIEludGVybmFsIGhlbHBlciBtZXRob2QgdG8gZmV0Y2ggdGhlIFJQQyBzZXJ2aWNlIGVuZHBvaW50LlxuICAgKiBAcGFyYW0gdXJsIFRoZSBVUkwgdG8gZmV0Y2guXG4gICAqIEBwYXJhbSBycGNSZXF1ZXN0IFRoZSBKU09OLVJQQyByZXF1ZXN0IHRvIHNlbmQuXG4gICAqIEBwYXJhbSBhY2NlcHRIZWFkZXIgVGhlIEFjY2VwdCBoZWFkZXIgdG8gdXNlLiAgRGVmYXVsdHMgdG8gXCJhcHBsaWNhdGlvbi9qc29uXCIuXG4gICAqIEByZXR1cm5zIEEgUHJvbWlzZSB0aGF0IHJlc29sdmVzIHRvIHRoZSBmZXRjaCBIVFRQIHJlc3BvbnNlLlxuICAgKi9cbiAgYXN5bmMgX2ZldGNoUnBjKHVybCwgcnBjUmVxdWVzdCwgYWNjZXB0SGVhZGVyID0gXCJhcHBsaWNhdGlvbi9qc29uXCIpIHtcbiAgICBjb25zdCByZXF1ZXN0SW5pdCA9IHtcbiAgICAgIG1ldGhvZDogXCJQT1NUXCIsXG4gICAgICBoZWFkZXJzOiB7XG4gICAgICAgIFwiQ29udGVudC1UeXBlXCI6IFwiYXBwbGljYXRpb24vanNvblwiLFxuICAgICAgICBcIkFjY2VwdFwiOiBhY2NlcHRIZWFkZXJcbiAgICAgICAgLy8gRXhwZWN0IEpTT04gcmVzcG9uc2UgZm9yIG5vbi1zdHJlYW1pbmcgcmVxdWVzdHNcbiAgICAgIH0sXG4gICAgICBib2R5OiBKU09OLnN0cmluZ2lmeShycGNSZXF1ZXN0KVxuICAgIH07XG4gICAgcmV0dXJuIHRoaXMuX2ZldGNoKHVybCwgcmVxdWVzdEluaXQpO1xuICB9XG4gIC8qKlxuICAgKiBTZW5kcyBhIG1lc3NhZ2UgdG8gdGhlIGFnZW50LlxuICAgKiBUaGUgYmVoYXZpb3IgKGJsb2NraW5nL25vbi1ibG9ja2luZykgYW5kIHB1c2ggbm90aWZpY2F0aW9uIGNvbmZpZ3VyYXRpb25cbiAgICogYXJlIHNwZWNpZmllZCB3aXRoaW4gdGhlIGBwYXJhbXMuY29uZmlndXJhdGlvbmAgb2JqZWN0LlxuICAgKiBPcHRpb25hbGx5LCBgcGFyYW1zLm1lc3NhZ2UuY29udGV4dElkYCBvciBgcGFyYW1zLm1lc3NhZ2UudGFza0lkYCBjYW4gYmUgcHJvdmlkZWQuXG4gICAqIEBwYXJhbSBwYXJhbXMgVGhlIHBhcmFtZXRlcnMgZm9yIHNlbmRpbmcgdGhlIG1lc3NhZ2UsIGluY2x1ZGluZyB0aGUgbWVzc2FnZSBjb250ZW50IGFuZCBjb25maWd1cmF0aW9uLlxuICAgKiBAcmV0dXJucyBBIFByb21pc2UgcmVzb2x2aW5nIHRvIFNlbmRNZXNzYWdlUmVzcG9uc2UsIHdoaWNoIGNhbiBiZSBhIE1lc3NhZ2UsIFRhc2ssIG9yIGFuIGVycm9yLlxuICAgKi9cbiAgYXN5bmMgc2VuZE1lc3NhZ2UocGFyYW1zKSB7XG4gICAgcmV0dXJuIHRoaXMuX3Bvc3RScGNSZXF1ZXN0KFwibWVzc2FnZS9zZW5kXCIsIHBhcmFtcyk7XG4gIH1cbiAgLyoqXG4gICAqIFNlbmRzIGEgbWVzc2FnZSB0byB0aGUgYWdlbnQgYW5kIHN0cmVhbXMgYmFjayByZXNwb25zZXMgdXNpbmcgU2VydmVyLVNlbnQgRXZlbnRzIChTU0UpLlxuICAgKiBQdXNoIG5vdGlmaWNhdGlvbiBjb25maWd1cmF0aW9uIGNhbiBiZSBzcGVjaWZpZWQgaW4gYHBhcmFtcy5jb25maWd1cmF0aW9uYC5cbiAgICogT3B0aW9uYWxseSwgYHBhcmFtcy5tZXNzYWdlLmNvbnRleHRJZGAgb3IgYHBhcmFtcy5tZXNzYWdlLnRhc2tJZGAgY2FuIGJlIHByb3ZpZGVkLlxuICAgKiBSZXF1aXJlcyB0aGUgYWdlbnQgdG8gc3VwcG9ydCBzdHJlYW1pbmcgKGBjYXBhYmlsaXRpZXMuc3RyZWFtaW5nOiB0cnVlYCBpbiBBZ2VudENhcmQpLlxuICAgKiBAcGFyYW0gcGFyYW1zIFRoZSBwYXJhbWV0ZXJzIGZvciBzZW5kaW5nIHRoZSBtZXNzYWdlLlxuICAgKiBAcmV0dXJucyBBbiBBc3luY0dlbmVyYXRvciB5aWVsZGluZyBBMkFTdHJlYW1FdmVudERhdGEgKE1lc3NhZ2UsIFRhc2ssIFRhc2tTdGF0dXNVcGRhdGVFdmVudCwgb3IgVGFza0FydGlmYWN0VXBkYXRlRXZlbnQpLlxuICAgKiBUaGUgZ2VuZXJhdG9yIHRocm93cyBhbiBlcnJvciBpZiBzdHJlYW1pbmcgaXMgbm90IHN1cHBvcnRlZCBvciBpZiBhbiBIVFRQL1NTRSBlcnJvciBvY2N1cnMuXG4gICAqL1xuICBhc3luYyAqc2VuZE1lc3NhZ2VTdHJlYW0ocGFyYW1zKSB7XG4gICAgY29uc3QgYWdlbnRDYXJkID0gYXdhaXQgdGhpcy5hZ2VudENhcmRQcm9taXNlO1xuICAgIGlmICghYWdlbnRDYXJkLmNhcGFiaWxpdGllcz8uc3RyZWFtaW5nKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJBZ2VudCBkb2VzIG5vdCBzdXBwb3J0IHN0cmVhbWluZyAoQWdlbnRDYXJkLmNhcGFiaWxpdGllcy5zdHJlYW1pbmcgaXMgbm90IHRydWUpLlwiKTtcbiAgICB9XG4gICAgY29uc3QgZW5kcG9pbnQgPSBhd2FpdCB0aGlzLl9nZXRTZXJ2aWNlRW5kcG9pbnQoKTtcbiAgICBjb25zdCBjbGllbnRSZXF1ZXN0SWQgPSB0aGlzLnJlcXVlc3RJZENvdW50ZXIrKztcbiAgICBjb25zdCBycGNSZXF1ZXN0ID0ge1xuICAgICAgLy8gVGhpcyBpcyB0aGUgaW5pdGlhbCBKU09OLVJQQyByZXF1ZXN0IHRvIGVzdGFibGlzaCB0aGUgc3RyZWFtXG4gICAgICBqc29ucnBjOiBcIjIuMFwiLFxuICAgICAgbWV0aG9kOiBcIm1lc3NhZ2Uvc3RyZWFtXCIsXG4gICAgICBwYXJhbXMsXG4gICAgICBpZDogY2xpZW50UmVxdWVzdElkXG4gICAgfTtcbiAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHRoaXMuX2ZldGNoUnBjKGVuZHBvaW50LCBycGNSZXF1ZXN0LCBcInRleHQvZXZlbnQtc3RyZWFtXCIpO1xuICAgIGlmICghcmVzcG9uc2Uub2spIHtcbiAgICAgIGxldCBlcnJvckJvZHkgPSBcIlwiO1xuICAgICAgdHJ5IHtcbiAgICAgICAgZXJyb3JCb2R5ID0gYXdhaXQgcmVzcG9uc2UudGV4dCgpO1xuICAgICAgICBjb25zdCBlcnJvckpzb24gPSBKU09OLnBhcnNlKGVycm9yQm9keSk7XG4gICAgICAgIGlmIChlcnJvckpzb24uZXJyb3IpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEhUVFAgZXJyb3IgZXN0YWJsaXNoaW5nIHN0cmVhbSBmb3IgbWVzc2FnZS9zdHJlYW06ICR7cmVzcG9uc2Uuc3RhdHVzfSAke3Jlc3BvbnNlLnN0YXR1c1RleHR9LiBSUEMgRXJyb3I6ICR7ZXJyb3JKc29uLmVycm9yLm1lc3NhZ2V9IChDb2RlOiAke2Vycm9ySnNvbi5lcnJvci5jb2RlfSlgKTtcbiAgICAgICAgfVxuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBpZiAoZS5tZXNzYWdlLnN0YXJ0c1dpdGgoXCJIVFRQIGVycm9yIGVzdGFibGlzaGluZyBzdHJlYW1cIikpIHRocm93IGU7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgSFRUUCBlcnJvciBlc3RhYmxpc2hpbmcgc3RyZWFtIGZvciBtZXNzYWdlL3N0cmVhbTogJHtyZXNwb25zZS5zdGF0dXN9ICR7cmVzcG9uc2Uuc3RhdHVzVGV4dH0uIFJlc3BvbnNlOiAke2Vycm9yQm9keSB8fCBcIihlbXB0eSlcIn1gKTtcbiAgICAgIH1cbiAgICAgIHRocm93IG5ldyBFcnJvcihgSFRUUCBlcnJvciBlc3RhYmxpc2hpbmcgc3RyZWFtIGZvciBtZXNzYWdlL3N0cmVhbTogJHtyZXNwb25zZS5zdGF0dXN9ICR7cmVzcG9uc2Uuc3RhdHVzVGV4dH1gKTtcbiAgICB9XG4gICAgaWYgKCFyZXNwb25zZS5oZWFkZXJzLmdldChcIkNvbnRlbnQtVHlwZVwiKT8uc3RhcnRzV2l0aChcInRleHQvZXZlbnQtc3RyZWFtXCIpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIHJlc3BvbnNlIENvbnRlbnQtVHlwZSBmb3IgU1NFIHN0cmVhbS4gRXhwZWN0ZWQgJ3RleHQvZXZlbnQtc3RyZWFtJy5cIik7XG4gICAgfVxuICAgIHlpZWxkKiB0aGlzLl9wYXJzZUEyQVNzZVN0cmVhbShyZXNwb25zZSwgY2xpZW50UmVxdWVzdElkKTtcbiAgfVxuICAvKipcbiAgICogU2V0cyBvciB1cGRhdGVzIHRoZSBwdXNoIG5vdGlmaWNhdGlvbiBjb25maWd1cmF0aW9uIGZvciBhIGdpdmVuIHRhc2suXG4gICAqIFJlcXVpcmVzIHRoZSBhZ2VudCB0byBzdXBwb3J0IHB1c2ggbm90aWZpY2F0aW9ucyAoYGNhcGFiaWxpdGllcy5wdXNoTm90aWZpY2F0aW9uczogdHJ1ZWAgaW4gQWdlbnRDYXJkKS5cbiAgICogQHBhcmFtIHBhcmFtcyBQYXJhbWV0ZXJzIGNvbnRhaW5pbmcgdGhlIHRhc2tJZCBhbmQgdGhlIFRhc2tQdXNoTm90aWZpY2F0aW9uQ29uZmlnLlxuICAgKiBAcmV0dXJucyBBIFByb21pc2UgcmVzb2x2aW5nIHRvIFNldFRhc2tQdXNoTm90aWZpY2F0aW9uQ29uZmlnUmVzcG9uc2UuXG4gICAqL1xuICBhc3luYyBzZXRUYXNrUHVzaE5vdGlmaWNhdGlvbkNvbmZpZyhwYXJhbXMpIHtcbiAgICBjb25zdCBhZ2VudENhcmQgPSBhd2FpdCB0aGlzLmFnZW50Q2FyZFByb21pc2U7XG4gICAgaWYgKCFhZ2VudENhcmQuY2FwYWJpbGl0aWVzPy5wdXNoTm90aWZpY2F0aW9ucykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQWdlbnQgZG9lcyBub3Qgc3VwcG9ydCBwdXNoIG5vdGlmaWNhdGlvbnMgKEFnZW50Q2FyZC5jYXBhYmlsaXRpZXMucHVzaE5vdGlmaWNhdGlvbnMgaXMgbm90IHRydWUpLlwiKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuX3Bvc3RScGNSZXF1ZXN0KFxuICAgICAgXCJ0YXNrcy9wdXNoTm90aWZpY2F0aW9uQ29uZmlnL3NldFwiLFxuICAgICAgcGFyYW1zXG4gICAgKTtcbiAgfVxuICAvKipcbiAgICogR2V0cyB0aGUgcHVzaCBub3RpZmljYXRpb24gY29uZmlndXJhdGlvbiBmb3IgYSBnaXZlbiB0YXNrLlxuICAgKiBAcGFyYW0gcGFyYW1zIFBhcmFtZXRlcnMgY29udGFpbmluZyB0aGUgdGFza0lkLlxuICAgKiBAcmV0dXJucyBBIFByb21pc2UgcmVzb2x2aW5nIHRvIEdldFRhc2tQdXNoTm90aWZpY2F0aW9uQ29uZmlnUmVzcG9uc2UuXG4gICAqL1xuICBhc3luYyBnZXRUYXNrUHVzaE5vdGlmaWNhdGlvbkNvbmZpZyhwYXJhbXMpIHtcbiAgICByZXR1cm4gdGhpcy5fcG9zdFJwY1JlcXVlc3QoXG4gICAgICBcInRhc2tzL3B1c2hOb3RpZmljYXRpb25Db25maWcvZ2V0XCIsXG4gICAgICBwYXJhbXNcbiAgICApO1xuICB9XG4gIC8qKlxuICAgKiBMaXN0cyB0aGUgcHVzaCBub3RpZmljYXRpb24gY29uZmlndXJhdGlvbnMgZm9yIGEgZ2l2ZW4gdGFzay5cbiAgICogQHBhcmFtIHBhcmFtcyBQYXJhbWV0ZXJzIGNvbnRhaW5pbmcgdGhlIHRhc2tJZC5cbiAgICogQHJldHVybnMgQSBQcm9taXNlIHJlc29sdmluZyB0byBMaXN0VGFza1B1c2hOb3RpZmljYXRpb25Db25maWdSZXNwb25zZS5cbiAgICovXG4gIGFzeW5jIGxpc3RUYXNrUHVzaE5vdGlmaWNhdGlvbkNvbmZpZyhwYXJhbXMpIHtcbiAgICByZXR1cm4gdGhpcy5fcG9zdFJwY1JlcXVlc3QoXG4gICAgICBcInRhc2tzL3B1c2hOb3RpZmljYXRpb25Db25maWcvbGlzdFwiLFxuICAgICAgcGFyYW1zXG4gICAgKTtcbiAgfVxuICAvKipcbiAgICogRGVsZXRlcyB0aGUgcHVzaCBub3RpZmljYXRpb24gY29uZmlndXJhdGlvbiBmb3IgYSBnaXZlbiB0YXNrLlxuICAgKiBAcGFyYW0gcGFyYW1zIFBhcmFtZXRlcnMgY29udGFpbmluZyB0aGUgdGFza0lkIGFuZCBwdXNoIG5vdGlmaWNhdGlvbiBjb25maWd1cmF0aW9uIElELlxuICAgKiBAcmV0dXJucyBBIFByb21pc2UgcmVzb2x2aW5nIHRvIERlbGV0ZVRhc2tQdXNoTm90aWZpY2F0aW9uQ29uZmlnUmVzcG9uc2UuXG4gICAqL1xuICBhc3luYyBkZWxldGVUYXNrUHVzaE5vdGlmaWNhdGlvbkNvbmZpZyhwYXJhbXMpIHtcbiAgICByZXR1cm4gdGhpcy5fcG9zdFJwY1JlcXVlc3QoXG4gICAgICBcInRhc2tzL3B1c2hOb3RpZmljYXRpb25Db25maWcvZGVsZXRlXCIsXG4gICAgICBwYXJhbXNcbiAgICApO1xuICB9XG4gIC8qKlxuICAgKiBSZXRyaWV2ZXMgYSB0YXNrIGJ5IGl0cyBJRC5cbiAgICogQHBhcmFtIHBhcmFtcyBQYXJhbWV0ZXJzIGNvbnRhaW5pbmcgdGhlIHRhc2tJZCBhbmQgb3B0aW9uYWwgaGlzdG9yeUxlbmd0aC5cbiAgICogQHJldHVybnMgQSBQcm9taXNlIHJlc29sdmluZyB0byBHZXRUYXNrUmVzcG9uc2UsIHdoaWNoIGNvbnRhaW5zIHRoZSBUYXNrIG9iamVjdCBvciBhbiBlcnJvci5cbiAgICovXG4gIGFzeW5jIGdldFRhc2socGFyYW1zKSB7XG4gICAgcmV0dXJuIHRoaXMuX3Bvc3RScGNSZXF1ZXN0KFwidGFza3MvZ2V0XCIsIHBhcmFtcyk7XG4gIH1cbiAgLyoqXG4gICAqIENhbmNlbHMgYSB0YXNrIGJ5IGl0cyBJRC5cbiAgICogQHBhcmFtIHBhcmFtcyBQYXJhbWV0ZXJzIGNvbnRhaW5pbmcgdGhlIHRhc2tJZC5cbiAgICogQHJldHVybnMgQSBQcm9taXNlIHJlc29sdmluZyB0byBDYW5jZWxUYXNrUmVzcG9uc2UsIHdoaWNoIGNvbnRhaW5zIHRoZSB1cGRhdGVkIFRhc2sgb2JqZWN0IG9yIGFuIGVycm9yLlxuICAgKi9cbiAgYXN5bmMgY2FuY2VsVGFzayhwYXJhbXMpIHtcbiAgICByZXR1cm4gdGhpcy5fcG9zdFJwY1JlcXVlc3QoXCJ0YXNrcy9jYW5jZWxcIiwgcGFyYW1zKTtcbiAgfVxuICAvKipcbiAgICogQHRlbXBsYXRlIFRFeHRlbnNpb25QYXJhbXMgVGhlIHR5cGUgb2YgcGFyYW1ldGVycyBmb3IgdGhlIGN1c3RvbSBleHRlbnNpb24gbWV0aG9kLlxuICAgKiBAdGVtcGxhdGUgVEV4dGVuc2lvblJlc3BvbnNlIFRoZSB0eXBlIG9mIHJlc3BvbnNlIGV4cGVjdGVkIGZyb20gdGhlIGN1c3RvbSBleHRlbnNpb24gbWV0aG9kLiBcbiAgICogVGhpcyBzaG91bGQgZXh0ZW5kIEpTT05SUENSZXNwb25zZS4gVGhpcyBlbnN1cmVzIHRoZSBleHRlbnNpb24gcmVzcG9uc2UgaXMgc3RpbGwgYSB2YWxpZCBBMkEgcmVzcG9uc2UuXG4gICAqIEBwYXJhbSBtZXRob2QgQ3VzdG9tIEpTT04tUlBDIG1ldGhvZCBkZWZpbmVkIGluIHRoZSBBZ2VudENhcmQncyBleHRlbnNpb25zLlxuICAgKiBAcGFyYW0gcGFyYW1zIEV4dGVuc2lvbiBwYXJhbXRlcnMgZGVmaW5lZCBpbiB0aGUgQWdlbnRDYXJkJ3MgZXh0ZW5zaW9ucy5cbiAgICogQHJldHVybnMgQSBQcm9taXNlIHRoYXQgcmVzb2x2ZXMgdG8gdGhlIFJQQyByZXNwb25zZS5cbiAgICovXG4gIGFzeW5jIGNhbGxFeHRlbnNpb25NZXRob2QobWV0aG9kLCBwYXJhbXMpIHtcbiAgICByZXR1cm4gdGhpcy5fcG9zdFJwY1JlcXVlc3QobWV0aG9kLCBwYXJhbXMpO1xuICB9XG4gIC8qKlxuICAgKiBSZXN1YnNjcmliZXMgdG8gYSB0YXNrJ3MgZXZlbnQgc3RyZWFtIHVzaW5nIFNlcnZlci1TZW50IEV2ZW50cyAoU1NFKS5cbiAgICogVGhpcyBpcyB1c2VkIGlmIGEgcHJldmlvdXMgU1NFIGNvbm5lY3Rpb24gZm9yIGFuIGFjdGl2ZSB0YXNrIHdhcyBicm9rZW4uXG4gICAqIFJlcXVpcmVzIHRoZSBhZ2VudCB0byBzdXBwb3J0IHN0cmVhbWluZyAoYGNhcGFiaWxpdGllcy5zdHJlYW1pbmc6IHRydWVgIGluIEFnZW50Q2FyZCkuXG4gICAqIEBwYXJhbSBwYXJhbXMgUGFyYW1ldGVycyBjb250YWluaW5nIHRoZSB0YXNrSWQuXG4gICAqIEByZXR1cm5zIEFuIEFzeW5jR2VuZXJhdG9yIHlpZWxkaW5nIEEyQVN0cmVhbUV2ZW50RGF0YSAoTWVzc2FnZSwgVGFzaywgVGFza1N0YXR1c1VwZGF0ZUV2ZW50LCBvciBUYXNrQXJ0aWZhY3RVcGRhdGVFdmVudCkuXG4gICAqL1xuICBhc3luYyAqcmVzdWJzY3JpYmVUYXNrKHBhcmFtcykge1xuICAgIGNvbnN0IGFnZW50Q2FyZCA9IGF3YWl0IHRoaXMuYWdlbnRDYXJkUHJvbWlzZTtcbiAgICBpZiAoIWFnZW50Q2FyZC5jYXBhYmlsaXRpZXM/LnN0cmVhbWluZykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQWdlbnQgZG9lcyBub3Qgc3VwcG9ydCBzdHJlYW1pbmcgKHJlcXVpcmVkIGZvciB0YXNrcy9yZXN1YnNjcmliZSkuXCIpO1xuICAgIH1cbiAgICBjb25zdCBlbmRwb2ludCA9IGF3YWl0IHRoaXMuX2dldFNlcnZpY2VFbmRwb2ludCgpO1xuICAgIGNvbnN0IGNsaWVudFJlcXVlc3RJZCA9IHRoaXMucmVxdWVzdElkQ291bnRlcisrO1xuICAgIGNvbnN0IHJwY1JlcXVlc3QgPSB7XG4gICAgICAvLyBJbml0aWFsIEpTT04tUlBDIHJlcXVlc3QgdG8gZXN0YWJsaXNoIHRoZSBzdHJlYW1cbiAgICAgIGpzb25ycGM6IFwiMi4wXCIsXG4gICAgICBtZXRob2Q6IFwidGFza3MvcmVzdWJzY3JpYmVcIixcbiAgICAgIHBhcmFtcyxcbiAgICAgIGlkOiBjbGllbnRSZXF1ZXN0SWRcbiAgICB9O1xuICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5fZmV0Y2goZW5kcG9pbnQsIHtcbiAgICAgIG1ldGhvZDogXCJQT1NUXCIsXG4gICAgICBoZWFkZXJzOiB7XG4gICAgICAgIFwiQ29udGVudC1UeXBlXCI6IFwiYXBwbGljYXRpb24vanNvblwiLFxuICAgICAgICBcIkFjY2VwdFwiOiBcInRleHQvZXZlbnQtc3RyZWFtXCJcbiAgICAgIH0sXG4gICAgICBib2R5OiBKU09OLnN0cmluZ2lmeShycGNSZXF1ZXN0KVxuICAgIH0pO1xuICAgIGlmICghcmVzcG9uc2Uub2spIHtcbiAgICAgIGxldCBlcnJvckJvZHkgPSBcIlwiO1xuICAgICAgdHJ5IHtcbiAgICAgICAgZXJyb3JCb2R5ID0gYXdhaXQgcmVzcG9uc2UudGV4dCgpO1xuICAgICAgICBjb25zdCBlcnJvckpzb24gPSBKU09OLnBhcnNlKGVycm9yQm9keSk7XG4gICAgICAgIGlmIChlcnJvckpzb24uZXJyb3IpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEhUVFAgZXJyb3IgZXN0YWJsaXNoaW5nIHN0cmVhbSBmb3IgdGFza3MvcmVzdWJzY3JpYmU6ICR7cmVzcG9uc2Uuc3RhdHVzfSAke3Jlc3BvbnNlLnN0YXR1c1RleHR9LiBSUEMgRXJyb3I6ICR7ZXJyb3JKc29uLmVycm9yLm1lc3NhZ2V9IChDb2RlOiAke2Vycm9ySnNvbi5lcnJvci5jb2RlfSlgKTtcbiAgICAgICAgfVxuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBpZiAoZS5tZXNzYWdlLnN0YXJ0c1dpdGgoXCJIVFRQIGVycm9yIGVzdGFibGlzaGluZyBzdHJlYW1cIikpIHRocm93IGU7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgSFRUUCBlcnJvciBlc3RhYmxpc2hpbmcgc3RyZWFtIGZvciB0YXNrcy9yZXN1YnNjcmliZTogJHtyZXNwb25zZS5zdGF0dXN9ICR7cmVzcG9uc2Uuc3RhdHVzVGV4dH0uIFJlc3BvbnNlOiAke2Vycm9yQm9keSB8fCBcIihlbXB0eSlcIn1gKTtcbiAgICAgIH1cbiAgICAgIHRocm93IG5ldyBFcnJvcihgSFRUUCBlcnJvciBlc3RhYmxpc2hpbmcgc3RyZWFtIGZvciB0YXNrcy9yZXN1YnNjcmliZTogJHtyZXNwb25zZS5zdGF0dXN9ICR7cmVzcG9uc2Uuc3RhdHVzVGV4dH1gKTtcbiAgICB9XG4gICAgaWYgKCFyZXNwb25zZS5oZWFkZXJzLmdldChcIkNvbnRlbnQtVHlwZVwiKT8uc3RhcnRzV2l0aChcInRleHQvZXZlbnQtc3RyZWFtXCIpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIHJlc3BvbnNlIENvbnRlbnQtVHlwZSBmb3IgU1NFIHN0cmVhbSBvbiByZXN1YnNjcmliZS4gRXhwZWN0ZWQgJ3RleHQvZXZlbnQtc3RyZWFtJy5cIik7XG4gICAgfVxuICAgIHlpZWxkKiB0aGlzLl9wYXJzZUEyQVNzZVN0cmVhbShyZXNwb25zZSwgY2xpZW50UmVxdWVzdElkKTtcbiAgfVxuICAvKipcbiAgICogUGFyc2VzIGFuIEhUVFAgcmVzcG9uc2UgYm9keSBhcyBhbiBBMkEgU2VydmVyLVNlbnQgRXZlbnQgc3RyZWFtLlxuICAgKiBFYWNoICdkYXRhJyBmaWVsZCBvZiBhbiBTU0UgZXZlbnQgaXMgZXhwZWN0ZWQgdG8gYmUgYSBKU09OLVJQQyAyLjAgUmVzcG9uc2Ugb2JqZWN0LFxuICAgKiBzcGVjaWZpY2FsbHkgYSBTZW5kU3RyZWFtaW5nTWVzc2FnZVJlc3BvbnNlIChvciBzaW1pbGFyIHN0cnVjdHVyZSBmb3IgcmVzdWJzY3JpYmUpLlxuICAgKiBAcGFyYW0gcmVzcG9uc2UgVGhlIEhUVFAgUmVzcG9uc2Ugb2JqZWN0IHdob3NlIGJvZHkgaXMgdGhlIFNTRSBzdHJlYW0uXG4gICAqIEBwYXJhbSBvcmlnaW5hbFJlcXVlc3RJZCBUaGUgSUQgb2YgdGhlIGNsaWVudCdzIEpTT04tUlBDIHJlcXVlc3QgdGhhdCBpbml0aWF0ZWQgdGhpcyBzdHJlYW0uXG4gICAqIFVzZWQgdG8gdmFsaWRhdGUgdGhlIGBpZGAgaW4gdGhlIHN0cmVhbWVkIEpTT04tUlBDIHJlc3BvbnNlcy5cbiAgICogQHJldHVybnMgQW4gQXN5bmNHZW5lcmF0b3IgeWllbGRpbmcgdGhlIGByZXN1bHRgIGZpZWxkIG9mIGVhY2ggdmFsaWQgSlNPTi1SUEMgc3VjY2VzcyByZXNwb25zZSBmcm9tIHRoZSBzdHJlYW0uXG4gICAqL1xuICBhc3luYyAqX3BhcnNlQTJBU3NlU3RyZWFtKHJlc3BvbnNlLCBvcmlnaW5hbFJlcXVlc3RJZCkge1xuICAgIGlmICghcmVzcG9uc2UuYm9keSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiU1NFIHJlc3BvbnNlIGJvZHkgaXMgdW5kZWZpbmVkLiBDYW5ub3QgcmVhZCBzdHJlYW0uXCIpO1xuICAgIH1cbiAgICBjb25zdCByZWFkZXIgPSByZXNwb25zZS5ib2R5LnBpcGVUaHJvdWdoKG5ldyBUZXh0RGVjb2RlclN0cmVhbSgpKS5nZXRSZWFkZXIoKTtcbiAgICBsZXQgYnVmZmVyID0gXCJcIjtcbiAgICBsZXQgZXZlbnREYXRhQnVmZmVyID0gXCJcIjtcbiAgICB0cnkge1xuICAgICAgd2hpbGUgKHRydWUpIHtcbiAgICAgICAgY29uc3QgeyBkb25lLCB2YWx1ZSB9ID0gYXdhaXQgcmVhZGVyLnJlYWQoKTtcbiAgICAgICAgaWYgKGRvbmUpIHtcbiAgICAgICAgICBpZiAoZXZlbnREYXRhQnVmZmVyLnRyaW0oKSkge1xuICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gdGhpcy5fcHJvY2Vzc1NzZUV2ZW50RGF0YShldmVudERhdGFCdWZmZXIsIG9yaWdpbmFsUmVxdWVzdElkKTtcbiAgICAgICAgICAgIHlpZWxkIHJlc3VsdDtcbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgYnVmZmVyICs9IHZhbHVlO1xuICAgICAgICBsZXQgbGluZUVuZEluZGV4O1xuICAgICAgICB3aGlsZSAoKGxpbmVFbmRJbmRleCA9IGJ1ZmZlci5pbmRleE9mKFwiXFxuXCIpKSA+PSAwKSB7XG4gICAgICAgICAgY29uc3QgbGluZSA9IGJ1ZmZlci5zdWJzdHJpbmcoMCwgbGluZUVuZEluZGV4KS50cmltKCk7XG4gICAgICAgICAgYnVmZmVyID0gYnVmZmVyLnN1YnN0cmluZyhsaW5lRW5kSW5kZXggKyAxKTtcbiAgICAgICAgICBpZiAobGluZSA9PT0gXCJcIikge1xuICAgICAgICAgICAgaWYgKGV2ZW50RGF0YUJ1ZmZlcikge1xuICAgICAgICAgICAgICBjb25zdCByZXN1bHQgPSB0aGlzLl9wcm9jZXNzU3NlRXZlbnREYXRhKGV2ZW50RGF0YUJ1ZmZlciwgb3JpZ2luYWxSZXF1ZXN0SWQpO1xuICAgICAgICAgICAgICB5aWVsZCByZXN1bHQ7XG4gICAgICAgICAgICAgIGV2ZW50RGF0YUJ1ZmZlciA9IFwiXCI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIGlmIChsaW5lLnN0YXJ0c1dpdGgoXCJkYXRhOlwiKSkge1xuICAgICAgICAgICAgZXZlbnREYXRhQnVmZmVyICs9IGxpbmUuc3Vic3RyaW5nKDUpLnRyaW1TdGFydCgpICsgXCJcXG5cIjtcbiAgICAgICAgICB9IGVsc2UgaWYgKGxpbmUuc3RhcnRzV2l0aChcIjpcIikpIHtcbiAgICAgICAgICB9IGVsc2UgaWYgKGxpbmUuaW5jbHVkZXMoXCI6XCIpKSB7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoXCJFcnJvciByZWFkaW5nIG9yIHBhcnNpbmcgU1NFIHN0cmVhbTpcIiwgZXJyb3IubWVzc2FnZSk7XG4gICAgICB0aHJvdyBlcnJvcjtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgcmVhZGVyLnJlbGVhc2VMb2NrKCk7XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBQcm9jZXNzZXMgYSBzaW5nbGUgU1NFIGV2ZW50J3MgZGF0YSBzdHJpbmcsIGV4cGVjdGluZyBpdCB0byBiZSBhIEpTT04tUlBDIHJlc3BvbnNlLlxuICAgKiBAcGFyYW0ganNvbkRhdGEgVGhlIHN0cmluZyBjb250ZW50IGZyb20gb25lIG9yIG1vcmUgJ2RhdGE6JyBsaW5lcyBvZiBhbiBTU0UgZXZlbnQuXG4gICAqIEBwYXJhbSBvcmlnaW5hbFJlcXVlc3RJZCBUaGUgSUQgb2YgdGhlIGNsaWVudCdzIHJlcXVlc3QgdGhhdCBpbml0aWF0ZWQgdGhlIHN0cmVhbS5cbiAgICogQHJldHVybnMgVGhlIGByZXN1bHRgIGZpZWxkIG9mIHRoZSBwYXJzZWQgSlNPTi1SUEMgc3VjY2VzcyByZXNwb25zZS5cbiAgICogQHRocm93cyBFcnJvciBpZiBkYXRhIGlzIG5vdCB2YWxpZCBKU09OLCBub3QgYSB2YWxpZCBKU09OLVJQQyByZXNwb25zZSwgYW4gZXJyb3IgcmVzcG9uc2UsIG9yIElEIG1pc21hdGNoLlxuICAgKi9cbiAgX3Byb2Nlc3NTc2VFdmVudERhdGEoanNvbkRhdGEsIG9yaWdpbmFsUmVxdWVzdElkKSB7XG4gICAgaWYgKCFqc29uRGF0YS50cmltKCkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkF0dGVtcHRlZCB0byBwcm9jZXNzIGVtcHR5IFNTRSBldmVudCBkYXRhLlwiKTtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHNzZUpzb25ScGNSZXNwb25zZSA9IEpTT04ucGFyc2UoanNvbkRhdGEucmVwbGFjZSgvXFxuJC8sIFwiXCIpKTtcbiAgICAgIGNvbnN0IGEyYVN0cmVhbVJlc3BvbnNlID0gc3NlSnNvblJwY1Jlc3BvbnNlO1xuICAgICAgaWYgKGEyYVN0cmVhbVJlc3BvbnNlLmlkICE9PSBvcmlnaW5hbFJlcXVlc3RJZCkge1xuICAgICAgICBjb25zb2xlLndhcm4oYFNTRSBFdmVudCdzIEpTT04tUlBDIHJlc3BvbnNlIElEIG1pc21hdGNoLiBDbGllbnQgcmVxdWVzdCBJRDogJHtvcmlnaW5hbFJlcXVlc3RJZH0sIGV2ZW50IHJlc3BvbnNlIElEOiAke2EyYVN0cmVhbVJlc3BvbnNlLmlkfS5gKTtcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLmlzRXJyb3JSZXNwb25zZShhMmFTdHJlYW1SZXNwb25zZSkpIHtcbiAgICAgICAgY29uc3QgZXJyID0gYTJhU3RyZWFtUmVzcG9uc2UuZXJyb3I7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgU1NFIGV2ZW50IGNvbnRhaW5lZCBhbiBlcnJvcjogJHtlcnIubWVzc2FnZX0gKENvZGU6ICR7ZXJyLmNvZGV9KSBEYXRhOiAke0pTT04uc3RyaW5naWZ5KGVyci5kYXRhIHx8IHt9KX1gKTtcbiAgICAgIH1cbiAgICAgIGlmICghKFwicmVzdWx0XCIgaW4gYTJhU3RyZWFtUmVzcG9uc2UpIHx8IHR5cGVvZiBhMmFTdHJlYW1SZXNwb25zZS5yZXN1bHQgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBTU0UgZXZlbnQgSlNPTi1SUEMgcmVzcG9uc2UgaXMgbWlzc2luZyAncmVzdWx0JyBmaWVsZC4gRGF0YTogJHtqc29uRGF0YX1gKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHN1Y2Nlc3NSZXNwb25zZSA9IGEyYVN0cmVhbVJlc3BvbnNlO1xuICAgICAgcmV0dXJuIHN1Y2Nlc3NSZXNwb25zZS5yZXN1bHQ7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgaWYgKGUubWVzc2FnZS5zdGFydHNXaXRoKFwiU1NFIGV2ZW50IGNvbnRhaW5lZCBhbiBlcnJvclwiKSB8fCBlLm1lc3NhZ2Uuc3RhcnRzV2l0aChcIlNTRSBldmVudCBKU09OLVJQQyByZXNwb25zZSBpcyBtaXNzaW5nICdyZXN1bHQnIGZpZWxkXCIpKSB7XG4gICAgICAgIHRocm93IGU7XG4gICAgICB9XG4gICAgICBjb25zb2xlLmVycm9yKFwiRmFpbGVkIHRvIHBhcnNlIFNTRSBldmVudCBkYXRhIHN0cmluZyBvciB1bmV4cGVjdGVkIEpTT04tUlBDIHN0cnVjdHVyZTpcIiwganNvbkRhdGEsIGUpO1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBGYWlsZWQgdG8gcGFyc2UgU1NFIGV2ZW50IGRhdGE6IFwiJHtqc29uRGF0YS5zdWJzdHJpbmcoMCwgMTAwKX0uLi5cIi4gT3JpZ2luYWwgZXJyb3I6ICR7ZS5tZXNzYWdlfWApO1xuICAgIH1cbiAgfVxuICBpc0Vycm9yUmVzcG9uc2UocmVzcG9uc2UpIHtcbiAgICByZXR1cm4gXCJlcnJvclwiIGluIHJlc3BvbnNlO1xuICB9XG4gIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG4gIC8vIEZ1bmN0aW9ucyB1c2VkIHRvIHN1cHBvcnQgb2xkIEEyQUNsaWVudCBDb25zdHJ1Y3RvciB0byBiZSBkZXByZWNhdGVkIHNvb25cbiAgLy8gVE9ET3M6XG4gIC8vICogcmVtb3ZlIGBhZ2VudENhcmRQcm9taXNlYCwgYW5kIGp1c3QgdXNlIGFnZW50Q2FyZCBpbml0aWFsaXplZFxuICAvLyAqIF9nZXRTZXJ2aWNlRW5kcG9pbnQgY2FuIGJlIG1hZGUgc3luY2hyb25vdXMgb3IgZGVsZXRlZCBhbmQgYWNjZXNzZWQgdmlhXG4gIC8vICAgYWdlbnRDYXJkLnVybFxuICAvLyAqIGdldEFnZW50Q2FyZCBjaGFuZ2VkIHRvIHRoaXMuYWdlbnRDYXJkXG4gIC8vICogZGVsZXRlIHJlc29sdmVBZ2VudENhcmRVcmwoKSwgX2ZldGNoQW5kQ2FjaGVBZ2VudENhcmQoKSxcbiAgLy8gICBhZ2VudENhcmRQYXRoIGZyb20gQTJBQ2xpZW50T3B0aW9uc1xuICAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuICAvKipcbiAgICogRmV0Y2hlcyB0aGUgQWdlbnQgQ2FyZCBmcm9tIHRoZSBhZ2VudCdzIHdlbGwta25vd24gVVJJIGFuZCBjYWNoZXMgaXRzIHNlcnZpY2UgZW5kcG9pbnQgVVJMLlxuICAgKiBUaGlzIG1ldGhvZCBpcyBjYWxsZWQgYnkgdGhlIGNvbnN0cnVjdG9yLlxuICAgKiBAcGFyYW0gYWdlbnRCYXNlVXJsIFRoZSBiYXNlIFVSTCBvZiB0aGUgQTJBIGFnZW50IChlLmcuLCBodHRwczovL2FnZW50LmV4YW1wbGUuY29tKVxuICAgKiBAcGFyYW0gYWdlbnRDYXJkUGF0aCBwYXRoIHRvIHRoZSBhZ2VudCBjYXJkLCBkZWZhdWx0cyB0byAud2VsbC1rbm93bi9hZ2VudC1jYXJkLmpzb25cbiAgICogQHJldHVybnMgQSBQcm9taXNlIHRoYXQgcmVzb2x2ZXMgdG8gdGhlIEFnZW50Q2FyZC5cbiAgICovXG4gIGFzeW5jIF9mZXRjaEFuZENhY2hlQWdlbnRDYXJkKGFnZW50QmFzZVVybCwgYWdlbnRDYXJkUGF0aCkge1xuICAgIHRyeSB7XG4gICAgICBjb25zdCBhZ2VudENhcmRVcmwgPSB0aGlzLnJlc29sdmVBZ2VudENhcmRVcmwoYWdlbnRCYXNlVXJsLCBhZ2VudENhcmRQYXRoKTtcbiAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5fZmV0Y2goYWdlbnRDYXJkVXJsLCB7XG4gICAgICAgIGhlYWRlcnM6IHsgXCJBY2NlcHRcIjogXCJhcHBsaWNhdGlvbi9qc29uXCIgfVxuICAgICAgfSk7XG4gICAgICBpZiAoIXJlc3BvbnNlLm9rKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgRmFpbGVkIHRvIGZldGNoIEFnZW50IENhcmQgZnJvbSAke2FnZW50Q2FyZFVybH06ICR7cmVzcG9uc2Uuc3RhdHVzfSAke3Jlc3BvbnNlLnN0YXR1c1RleHR9YCk7XG4gICAgICB9XG4gICAgICBjb25zdCBhZ2VudENhcmQgPSBhd2FpdCByZXNwb25zZS5qc29uKCk7XG4gICAgICBpZiAoIWFnZW50Q2FyZC51cmwpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRmV0Y2hlZCBBZ2VudCBDYXJkIGRvZXMgbm90IGNvbnRhaW4gYSB2YWxpZCAndXJsJyBmb3IgdGhlIHNlcnZpY2UgZW5kcG9pbnQuXCIpO1xuICAgICAgfVxuICAgICAgdGhpcy5zZXJ2aWNlRW5kcG9pbnRVcmwgPSBhZ2VudENhcmQudXJsO1xuICAgICAgcmV0dXJuIGFnZW50Q2FyZDtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcihcIkVycm9yIGZldGNoaW5nIG9yIHBhcnNpbmcgQWdlbnQgQ2FyZDpcIiwgZXJyb3IpO1xuICAgICAgdGhyb3cgZXJyb3I7XG4gICAgfVxuICB9XG4gIC8qKlxuICAqIFJldHJpZXZlcyB0aGUgQWdlbnQgQ2FyZC5cbiAgKiBJZiBhbiBgYWdlbnRCYXNlVXJsYCBpcyBwcm92aWRlZCwgaXQgZmV0Y2hlcyB0aGUgY2FyZCBmcm9tIHRoYXQgc3BlY2lmaWMgVVJMLlxuICAqIE90aGVyd2lzZSwgaXQgcmV0dXJucyB0aGUgY2FyZCBmZXRjaGVkIGFuZCBjYWNoZWQgZHVyaW5nIGNsaWVudCBjb25zdHJ1Y3Rpb24uXG4gICogQHBhcmFtIGFnZW50QmFzZVVybCBPcHRpb25hbC4gVGhlIGJhc2UgVVJMIG9mIHRoZSBhZ2VudCB0byBmZXRjaCB0aGUgY2FyZCBmcm9tLlxuICAqIEBwYXJhbSBhZ2VudENhcmRQYXRoIHBhdGggdG8gdGhlIGFnZW50IGNhcmQsIGRlZmF1bHRzIHRvIC53ZWxsLWtub3duL2FnZW50LWNhcmQuanNvblxuICAqIElmIHByb3ZpZGVkLCB0aGlzIHdpbGwgZmV0Y2ggYSBuZXcgY2FyZCwgbm90IHVzZSB0aGUgY2FjaGVkIG9uZSBmcm9tIHRoZSBjb25zdHJ1Y3RvcidzIFVSTC5cbiAgKiBAcmV0dXJucyBBIFByb21pc2UgdGhhdCByZXNvbHZlcyB0byB0aGUgQWdlbnRDYXJkLlxuICAqL1xuICBhc3luYyBnZXRBZ2VudENhcmQoYWdlbnRCYXNlVXJsLCBhZ2VudENhcmRQYXRoKSB7XG4gICAgaWYgKGFnZW50QmFzZVVybCkge1xuICAgICAgY29uc3QgYWdlbnRDYXJkVXJsID0gdGhpcy5yZXNvbHZlQWdlbnRDYXJkVXJsKGFnZW50QmFzZVVybCwgYWdlbnRDYXJkUGF0aCk7XG4gICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHRoaXMuX2ZldGNoKGFnZW50Q2FyZFVybCwge1xuICAgICAgICBoZWFkZXJzOiB7IFwiQWNjZXB0XCI6IFwiYXBwbGljYXRpb24vanNvblwiIH1cbiAgICAgIH0pO1xuICAgICAgaWYgKCFyZXNwb25zZS5vaykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEZhaWxlZCB0byBmZXRjaCBBZ2VudCBDYXJkIGZyb20gJHthZ2VudENhcmRVcmx9OiAke3Jlc3BvbnNlLnN0YXR1c30gJHtyZXNwb25zZS5zdGF0dXNUZXh0fWApO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGF3YWl0IHJlc3BvbnNlLmpzb24oKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuYWdlbnRDYXJkUHJvbWlzZTtcbiAgfVxuICAvKipcbiAgICogRGV0ZXJtaW5lcyB0aGUgYWdlbnQgY2FyZCBVUkwgYmFzZWQgb24gdGhlIGFnZW50IFVSTC5cbiAgICogQHBhcmFtIGFnZW50QmFzZVVybCBUaGUgYWdlbnQgVVJMLlxuICAgKiBAcGFyYW0gYWdlbnRDYXJkUGF0aCBPcHRpb25hbCByZWxhdGl2ZSBwYXRoIHRvIHRoZSBhZ2VudCBjYXJkLCBkZWZhdWx0cyB0byAud2VsbC1rbm93bi9hZ2VudC1jYXJkLmpzb25cbiAgICovXG4gIHJlc29sdmVBZ2VudENhcmRVcmwoYWdlbnRCYXNlVXJsLCBhZ2VudENhcmRQYXRoID0gQUdFTlRfQ0FSRF9QQVRIKSB7XG4gICAgcmV0dXJuIGAke2FnZW50QmFzZVVybC5yZXBsYWNlKC9cXC8kLywgXCJcIil9LyR7YWdlbnRDYXJkUGF0aC5yZXBsYWNlKC9eXFwvLywgXCJcIil9YDtcbiAgfVxuICAvKipcbiAgICogR2V0cyB0aGUgUlBDIHNlcnZpY2UgZW5kcG9pbnQgVVJMLiBFbnN1cmVzIHRoZSBhZ2VudCBjYXJkIGhhcyBiZWVuIGZldGNoZWQgZmlyc3QuXG4gICAqIEByZXR1cm5zIEEgUHJvbWlzZSB0aGF0IHJlc29sdmVzIHRvIHRoZSBzZXJ2aWNlIGVuZHBvaW50IFVSTCBzdHJpbmcuXG4gICAqL1xuICBhc3luYyBfZ2V0U2VydmljZUVuZHBvaW50KCkge1xuICAgIGlmICh0aGlzLnNlcnZpY2VFbmRwb2ludFVybCkge1xuICAgICAgcmV0dXJuIHRoaXMuc2VydmljZUVuZHBvaW50VXJsO1xuICAgIH1cbiAgICBhd2FpdCB0aGlzLmFnZW50Q2FyZFByb21pc2U7XG4gICAgaWYgKCF0aGlzLnNlcnZpY2VFbmRwb2ludFVybCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQWdlbnQgQ2FyZCBVUkwgZm9yIFJQQyBlbmRwb2ludCBpcyBub3QgYXZhaWxhYmxlLiBGZXRjaGluZyBtaWdodCBoYXZlIGZhaWxlZC5cIik7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLnNlcnZpY2VFbmRwb2ludFVybDtcbiAgfVxufTtcblxuLy8gc3JjL2NsaWVudC9hdXRoLWhhbmRsZXIudHNcbmZ1bmN0aW9uIGNyZWF0ZUF1dGhlbnRpY2F0aW5nRmV0Y2hXaXRoUmV0cnkoZmV0Y2hJbXBsLCBhdXRoSGFuZGxlcikge1xuICBhc3luYyBmdW5jdGlvbiBhdXRoRmV0Y2godXJsLCBpbml0KSB7XG4gICAgY29uc3QgYXV0aEhlYWRlcnMgPSBhd2FpdCBhdXRoSGFuZGxlci5oZWFkZXJzKCkgfHwge307XG4gICAgY29uc3QgbWVyZ2VkSW5pdCA9IHtcbiAgICAgIC4uLmluaXQgfHwge30sXG4gICAgICBoZWFkZXJzOiB7XG4gICAgICAgIC4uLmF1dGhIZWFkZXJzLFxuICAgICAgICAuLi5pbml0Py5oZWFkZXJzIHx8IHt9XG4gICAgICB9XG4gICAgfTtcbiAgICBsZXQgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaEltcGwodXJsLCBtZXJnZWRJbml0KTtcbiAgICBjb25zdCB1cGRhdGVkSGVhZGVycyA9IGF3YWl0IGF1dGhIYW5kbGVyLnNob3VsZFJldHJ5V2l0aEhlYWRlcnMobWVyZ2VkSW5pdCwgcmVzcG9uc2UpO1xuICAgIGlmICh1cGRhdGVkSGVhZGVycykge1xuICAgICAgY29uc3QgcmV0cnlJbml0ID0ge1xuICAgICAgICAuLi5pbml0IHx8IHt9LFxuICAgICAgICBoZWFkZXJzOiB7XG4gICAgICAgICAgLi4udXBkYXRlZEhlYWRlcnMsXG4gICAgICAgICAgLi4uaW5pdD8uaGVhZGVycyB8fCB7fVxuICAgICAgICB9XG4gICAgICB9O1xuICAgICAgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaEltcGwodXJsLCByZXRyeUluaXQpO1xuICAgICAgaWYgKHJlc3BvbnNlLm9rICYmIGF1dGhIYW5kbGVyLm9uU3VjY2Vzc2Z1bFJldHJ5KSB7XG4gICAgICAgIGF3YWl0IGF1dGhIYW5kbGVyLm9uU3VjY2Vzc2Z1bFJldHJ5KHVwZGF0ZWRIZWFkZXJzKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJlc3BvbnNlO1xuICB9XG4gIE9iamVjdC5zZXRQcm90b3R5cGVPZihhdXRoRmV0Y2gsIE9iamVjdC5nZXRQcm90b3R5cGVPZihmZXRjaEltcGwpKTtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoYXV0aEZldGNoLCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyhmZXRjaEltcGwpKTtcbiAgcmV0dXJuIGF1dGhGZXRjaDtcbn1cbmV4cG9ydCB7XG4gIEEyQUNsaWVudCxcbiAgY3JlYXRlQXV0aGVudGljYXRpbmdGZXRjaFdpdGhSZXRyeVxufTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@a2a-js/sdk/dist/client/index.js\n"));

/***/ })

}]);